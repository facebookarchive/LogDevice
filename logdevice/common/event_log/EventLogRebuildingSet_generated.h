// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_EVENTLOGREBUILDINGSET_FACEBOOK_LOGDEVICE_EVENT_LOG_REBUILDING_SET_H_
#define FLATBUFFERS_GENERATED_EVENTLOGREBUILDINGSET_FACEBOOK_LOGDEVICE_EVENT_LOG_REBUILDING_SET_H_

#include "flatbuffers/flatbuffers.h"

namespace facebook {
namespace logdevice {
namespace event_log_rebuilding_set {

struct DonorComplete;

struct DonorProgress;

struct RecordTimeRange;

struct DataClassTimeRanges;

struct NodeInfo;

struct ShardInfo;

struct Set;

struct DonorComplete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IDX = 4,
    VT_VERSION = 6
  };
  uint64_t idx() const { return GetField<uint64_t>(VT_IDX, 0); }
  uint64_t version() const { return GetField<uint64_t>(VT_VERSION, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_IDX) &&
           VerifyField<uint64_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct DonorCompleteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx(uint64_t idx) { fbb_.AddElement<uint64_t>(DonorComplete::VT_IDX, idx, 0); }
  void add_version(uint64_t version) { fbb_.AddElement<uint64_t>(DonorComplete::VT_VERSION, version, 0); }
  DonorCompleteBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DonorCompleteBuilder &operator=(const DonorCompleteBuilder &);
  flatbuffers::Offset<DonorComplete> Finish() {
    auto o = flatbuffers::Offset<DonorComplete>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<DonorComplete> CreateDonorComplete(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t idx = 0,
    uint64_t version = 0) {
  DonorCompleteBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_idx(idx);
  return builder_.Finish();
}

struct DonorProgress FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IDX = 4,
    VT_TS = 6
  };
  uint64_t idx() const { return GetField<uint64_t>(VT_IDX, 0); }
  uint64_t ts() const { return GetField<uint64_t>(VT_TS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_IDX) &&
           VerifyField<uint64_t>(verifier, VT_TS) &&
           verifier.EndTable();
  }
};

struct DonorProgressBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx(uint64_t idx) { fbb_.AddElement<uint64_t>(DonorProgress::VT_IDX, idx, 0); }
  void add_ts(uint64_t ts) { fbb_.AddElement<uint64_t>(DonorProgress::VT_TS, ts, 0); }
  DonorProgressBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DonorProgressBuilder &operator=(const DonorProgressBuilder &);
  flatbuffers::Offset<DonorProgress> Finish() {
    auto o = flatbuffers::Offset<DonorProgress>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<DonorProgress> CreateDonorProgress(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t idx = 0,
    uint64_t ts = 0) {
  DonorProgressBuilder builder_(_fbb);
  builder_.add_ts(ts);
  builder_.add_idx(idx);
  return builder_.Finish();
}

struct RecordTimeRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_LOWER = 4,
    VT_UPPER = 6
  };
  uint64_t lower() const { return GetField<uint64_t>(VT_LOWER, 0); }
  uint64_t upper() const { return GetField<uint64_t>(VT_UPPER, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_LOWER) &&
           VerifyField<uint64_t>(verifier, VT_UPPER) &&
           verifier.EndTable();
  }
};

struct RecordTimeRangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lower(uint64_t lower) { fbb_.AddElement<uint64_t>(RecordTimeRange::VT_LOWER, lower, 0); }
  void add_upper(uint64_t upper) { fbb_.AddElement<uint64_t>(RecordTimeRange::VT_UPPER, upper, 0); }
  RecordTimeRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RecordTimeRangeBuilder &operator=(const RecordTimeRangeBuilder &);
  flatbuffers::Offset<RecordTimeRange> Finish() {
    auto o = flatbuffers::Offset<RecordTimeRange>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<RecordTimeRange> CreateRecordTimeRange(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t lower = 0,
    uint64_t upper = 0) {
  RecordTimeRangeBuilder builder_(_fbb);
  builder_.add_upper(upper);
  builder_.add_lower(lower);
  return builder_.Finish();
}

struct DataClassTimeRanges FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DC = 4,
    VT_TIME_RANGES = 6
  };
  uint8_t dc() const { return GetField<uint8_t>(VT_DC, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<RecordTimeRange>> *time_ranges() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RecordTimeRange>> *>(VT_TIME_RANGES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DC) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TIME_RANGES) &&
           verifier.Verify(time_ranges()) &&
           verifier.VerifyVectorOfTables(time_ranges()) &&
           verifier.EndTable();
  }
};

struct DataClassTimeRangesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dc(uint8_t dc) { fbb_.AddElement<uint8_t>(DataClassTimeRanges::VT_DC, dc, 0); }
  void add_time_ranges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RecordTimeRange>>> time_ranges) { fbb_.AddOffset(DataClassTimeRanges::VT_TIME_RANGES, time_ranges); }
  DataClassTimeRangesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DataClassTimeRangesBuilder &operator=(const DataClassTimeRangesBuilder &);
  flatbuffers::Offset<DataClassTimeRanges> Finish() {
    auto o = flatbuffers::Offset<DataClassTimeRanges>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<DataClassTimeRanges> CreateDataClassTimeRanges(flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t dc = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RecordTimeRange>>> time_ranges = 0) {
  DataClassTimeRangesBuilder builder_(_fbb);
  builder_.add_time_ranges(time_ranges);
  builder_.add_dc(dc);
  return builder_.Finish();
}

inline flatbuffers::Offset<DataClassTimeRanges> CreateDataClassTimeRangesDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t dc = 0,
    const std::vector<flatbuffers::Offset<RecordTimeRange>> *time_ranges = nullptr) {
  return CreateDataClassTimeRanges(_fbb, dc, time_ranges ? _fbb.CreateVector<flatbuffers::Offset<RecordTimeRange>>(*time_ranges) : 0);
}

struct NodeInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IDX = 4,
    VT_VERSION = 6,
    VT_MODE = 8,
    VT_DONORS_COMPLETE = 10,
    VT_DONORS_COMPLETE_AUTHORITATIVELY = 12,
    VT_AUTH_STATUS = 14,
    VT_DRAIN = 16,
    VT_RECOVERABLE = 18,
    VT_ACKED = 20,
    VT_ACK_LSN = 22,
    VT_ACK_VERSION = 24,
    VT_DC_DIRTY_RANGES = 26,
    VT_SOURCE = 28,
    VT_DETAILS = 30,
    VT_REBUILDING_STARTED_TS_MILLIS = 32,
    VT_REBUILDING_COMPLETED_TS_MILLIS = 34
  };
  uint64_t idx() const { return GetField<uint64_t>(VT_IDX, 0); }
  uint64_t version() const { return GetField<uint64_t>(VT_VERSION, 0); }
  int32_t mode() const { return GetField<int32_t>(VT_MODE, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<DonorComplete>> *donors_complete() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DonorComplete>> *>(VT_DONORS_COMPLETE); }
  const flatbuffers::Vector<flatbuffers::Offset<DonorComplete>> *donors_complete_authoritatively() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DonorComplete>> *>(VT_DONORS_COMPLETE_AUTHORITATIVELY); }
  int32_t auth_status() const { return GetField<int32_t>(VT_AUTH_STATUS, 0); }
  int32_t drain() const { return GetField<int32_t>(VT_DRAIN, 0); }
  bool recoverable() const { return GetField<uint8_t>(VT_RECOVERABLE, 0) != 0; }
  bool acked() const { return GetField<uint8_t>(VT_ACKED, 0) != 0; }
  uint64_t ack_lsn() const { return GetField<uint64_t>(VT_ACK_LSN, 0); }
  uint64_t ack_version() const { return GetField<uint64_t>(VT_ACK_VERSION, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<DataClassTimeRanges>> *dc_dirty_ranges() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DataClassTimeRanges>> *>(VT_DC_DIRTY_RANGES); }
  const flatbuffers::String *source() const { return GetPointer<const flatbuffers::String *>(VT_SOURCE); }
  const flatbuffers::String *details() const { return GetPointer<const flatbuffers::String *>(VT_DETAILS); }
  uint64_t rebuilding_started_ts_millis() const { return GetField<uint64_t>(VT_REBUILDING_STARTED_TS_MILLIS, 0); }
  uint64_t rebuilding_completed_ts_millis() const { return GetField<uint64_t>(VT_REBUILDING_COMPLETED_TS_MILLIS, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_IDX) &&
           VerifyField<uint64_t>(verifier, VT_VERSION) &&
           VerifyField<int32_t>(verifier, VT_MODE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DONORS_COMPLETE) &&
           verifier.Verify(donors_complete()) &&
           verifier.VerifyVectorOfTables(donors_complete()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DONORS_COMPLETE_AUTHORITATIVELY) &&
           verifier.Verify(donors_complete_authoritatively()) &&
           verifier.VerifyVectorOfTables(donors_complete_authoritatively()) &&
           VerifyField<int32_t>(verifier, VT_AUTH_STATUS) &&
           VerifyField<int32_t>(verifier, VT_DRAIN) &&
           VerifyField<uint8_t>(verifier, VT_RECOVERABLE) &&
           VerifyField<uint8_t>(verifier, VT_ACKED) &&
           VerifyField<uint64_t>(verifier, VT_ACK_LSN) &&
           VerifyField<uint64_t>(verifier, VT_ACK_VERSION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DC_DIRTY_RANGES) &&
           verifier.Verify(dc_dirty_ranges()) &&
           verifier.VerifyVectorOfTables(dc_dirty_ranges()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SOURCE) &&
           verifier.Verify(source()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DETAILS) &&
           verifier.Verify(details()) &&
           VerifyField<uint64_t>(verifier, VT_REBUILDING_STARTED_TS_MILLIS) &&
           VerifyField<uint64_t>(verifier, VT_REBUILDING_COMPLETED_TS_MILLIS) &&
           verifier.EndTable();
  }
};

struct NodeInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx(uint64_t idx) { fbb_.AddElement<uint64_t>(NodeInfo::VT_IDX, idx, 0); }
  void add_version(uint64_t version) { fbb_.AddElement<uint64_t>(NodeInfo::VT_VERSION, version, 0); }
  void add_mode(int32_t mode) { fbb_.AddElement<int32_t>(NodeInfo::VT_MODE, mode, 0); }
  void add_donors_complete(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DonorComplete>>> donors_complete) { fbb_.AddOffset(NodeInfo::VT_DONORS_COMPLETE, donors_complete); }
  void add_donors_complete_authoritatively(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DonorComplete>>> donors_complete_authoritatively) { fbb_.AddOffset(NodeInfo::VT_DONORS_COMPLETE_AUTHORITATIVELY, donors_complete_authoritatively); }
  void add_auth_status(int32_t auth_status) { fbb_.AddElement<int32_t>(NodeInfo::VT_AUTH_STATUS, auth_status, 0); }
  void add_drain(int32_t drain) { fbb_.AddElement<int32_t>(NodeInfo::VT_DRAIN, drain, 0); }
  void add_recoverable(bool recoverable) { fbb_.AddElement<uint8_t>(NodeInfo::VT_RECOVERABLE, static_cast<uint8_t>(recoverable), 0); }
  void add_acked(bool acked) { fbb_.AddElement<uint8_t>(NodeInfo::VT_ACKED, static_cast<uint8_t>(acked), 0); }
  void add_ack_lsn(uint64_t ack_lsn) { fbb_.AddElement<uint64_t>(NodeInfo::VT_ACK_LSN, ack_lsn, 0); }
  void add_ack_version(uint64_t ack_version) { fbb_.AddElement<uint64_t>(NodeInfo::VT_ACK_VERSION, ack_version, 0); }
  void add_dc_dirty_ranges(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataClassTimeRanges>>> dc_dirty_ranges) { fbb_.AddOffset(NodeInfo::VT_DC_DIRTY_RANGES, dc_dirty_ranges); }
  void add_source(flatbuffers::Offset<flatbuffers::String> source) { fbb_.AddOffset(NodeInfo::VT_SOURCE, source); }
  void add_details(flatbuffers::Offset<flatbuffers::String> details) { fbb_.AddOffset(NodeInfo::VT_DETAILS, details); }
  void add_rebuilding_started_ts_millis(uint64_t rebuilding_started_ts_millis) { fbb_.AddElement<uint64_t>(NodeInfo::VT_REBUILDING_STARTED_TS_MILLIS, rebuilding_started_ts_millis, 0); }
  void add_rebuilding_completed_ts_millis(uint64_t rebuilding_completed_ts_millis) { fbb_.AddElement<uint64_t>(NodeInfo::VT_REBUILDING_COMPLETED_TS_MILLIS, rebuilding_completed_ts_millis, 0); }
  NodeInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodeInfoBuilder &operator=(const NodeInfoBuilder &);
  flatbuffers::Offset<NodeInfo> Finish() {
    auto o = flatbuffers::Offset<NodeInfo>(fbb_.EndTable(start_, 16));
    return o;
  }
};

inline flatbuffers::Offset<NodeInfo> CreateNodeInfo(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t idx = 0,
    uint64_t version = 0,
    int32_t mode = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DonorComplete>>> donors_complete = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DonorComplete>>> donors_complete_authoritatively = 0,
    int32_t auth_status = 0,
    int32_t drain = 0,
    bool recoverable = false,
    bool acked = false,
    uint64_t ack_lsn = 0,
    uint64_t ack_version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DataClassTimeRanges>>> dc_dirty_ranges = 0,
    flatbuffers::Offset<flatbuffers::String> source = 0,
    flatbuffers::Offset<flatbuffers::String> details = 0,
    uint64_t rebuilding_started_ts_millis = 0,
    uint64_t rebuilding_completed_ts_millis = 0) {
  NodeInfoBuilder builder_(_fbb);
  builder_.add_rebuilding_completed_ts_millis(rebuilding_completed_ts_millis);
  builder_.add_rebuilding_started_ts_millis(rebuilding_started_ts_millis);
  builder_.add_ack_version(ack_version);
  builder_.add_ack_lsn(ack_lsn);
  builder_.add_version(version);
  builder_.add_idx(idx);
  builder_.add_details(details);
  builder_.add_source(source);
  builder_.add_dc_dirty_ranges(dc_dirty_ranges);
  builder_.add_drain(drain);
  builder_.add_auth_status(auth_status);
  builder_.add_donors_complete_authoritatively(donors_complete_authoritatively);
  builder_.add_donors_complete(donors_complete);
  builder_.add_mode(mode);
  builder_.add_acked(acked);
  builder_.add_recoverable(recoverable);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeInfo> CreateNodeInfoDirect(flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t idx = 0,
    uint64_t version = 0,
    int32_t mode = 0,
    const std::vector<flatbuffers::Offset<DonorComplete>> *donors_complete = nullptr,
    const std::vector<flatbuffers::Offset<DonorComplete>> *donors_complete_authoritatively = nullptr,
    int32_t auth_status = 0,
    int32_t drain = 0,
    bool recoverable = false,
    bool acked = false,
    uint64_t ack_lsn = 0,
    uint64_t ack_version = 0,
    const std::vector<flatbuffers::Offset<DataClassTimeRanges>> *dc_dirty_ranges = nullptr,
    const char *source = nullptr,
    const char *details = nullptr,
    uint64_t rebuilding_started_ts_millis = 0,
    uint64_t rebuilding_completed_ts_millis = 0) {
  return CreateNodeInfo(_fbb, idx, version, mode, donors_complete ? _fbb.CreateVector<flatbuffers::Offset<DonorComplete>>(*donors_complete) : 0, donors_complete_authoritatively ? _fbb.CreateVector<flatbuffers::Offset<DonorComplete>>(*donors_complete_authoritatively) : 0, auth_status, drain, recoverable, acked, ack_lsn, ack_version, dc_dirty_ranges ? _fbb.CreateVector<flatbuffers::Offset<DataClassTimeRanges>>(*dc_dirty_ranges) : 0, source ? _fbb.CreateString(source) : 0, details ? _fbb.CreateString(details) : 0, rebuilding_started_ts_millis, rebuilding_completed_ts_millis);
}

struct ShardInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IDX = 4,
    VT_VERSION = 6,
    VT_NODES = 8,
    VT_DONOR_PROGRESS = 10,
    VT_FILTER_RELOCATE_SHARDS = 12
  };
  uint64_t idx() const { return GetField<uint64_t>(VT_IDX, 0); }
  uint64_t version() const { return GetField<uint64_t>(VT_VERSION, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<NodeInfo>> *nodes() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeInfo>> *>(VT_NODES); }
  const flatbuffers::Vector<flatbuffers::Offset<DonorProgress>> *donor_progress() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DonorProgress>> *>(VT_DONOR_PROGRESS); }
  bool filter_relocate_shards() const {
    return GetField<uint8_t>(VT_FILTER_RELOCATE_SHARDS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
        VerifyField<uint64_t>(verifier, VT_IDX) &&
        VerifyField<uint64_t>(verifier, VT_VERSION) &&
        VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODES) &&
        verifier.Verify(nodes()) && verifier.VerifyVectorOfTables(nodes()) &&
        VerifyField<flatbuffers::uoffset_t>(verifier, VT_DONOR_PROGRESS) &&
        verifier.Verify(donor_progress()) &&
        verifier.VerifyVectorOfTables(donor_progress()) &&
        VerifyField<uint8_t>(verifier, VT_FILTER_RELOCATE_SHARDS) &&
        verifier.EndTable();
  }
};

struct ShardInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx(uint64_t idx) { fbb_.AddElement<uint64_t>(ShardInfo::VT_IDX, idx, 0); }
  void add_version(uint64_t version) { fbb_.AddElement<uint64_t>(ShardInfo::VT_VERSION, version, 0); }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeInfo>>> nodes) { fbb_.AddOffset(ShardInfo::VT_NODES, nodes); }
  void add_donor_progress(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DonorProgress>>> donor_progress) { fbb_.AddOffset(ShardInfo::VT_DONOR_PROGRESS, donor_progress); }
  void add_filter_relocate_shards(bool filter_relocate_shards) {
    fbb_.AddElement<uint8_t>(ShardInfo::VT_FILTER_RELOCATE_SHARDS,
                             static_cast<uint8_t>(filter_relocate_shards),
                             0);
  }
  ShardInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ShardInfoBuilder &operator=(const ShardInfoBuilder &);
  flatbuffers::Offset<ShardInfo> Finish() {
    auto o = flatbuffers::Offset<ShardInfo>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<ShardInfo> CreateShardInfo(
    flatbuffers::FlatBufferBuilder& _fbb,
    uint64_t idx = 0,
    uint64_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeInfo>>>
        nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DonorProgress>>>
        donor_progress = 0,
    bool filter_relocate_shards = false) {
  ShardInfoBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_idx(idx);
  builder_.add_donor_progress(donor_progress);
  builder_.add_nodes(nodes);
  builder_.add_filter_relocate_shards(filter_relocate_shards);
  return builder_.Finish();
}

inline flatbuffers::Offset<ShardInfo> CreateShardInfoDirect(
    flatbuffers::FlatBufferBuilder& _fbb,
    uint64_t idx = 0,
    uint64_t version = 0,
    const std::vector<flatbuffers::Offset<NodeInfo>>* nodes = nullptr,
    const std::vector<flatbuffers::Offset<DonorProgress>>* donor_progress =
        nullptr,
    bool filter_relocate_shards = false) {
  return CreateShardInfo(
      _fbb,
      idx,
      version,
      nodes ? _fbb.CreateVector<flatbuffers::Offset<NodeInfo>>(*nodes) : 0,
      donor_progress ? _fbb.CreateVector<flatbuffers::Offset<DonorProgress>>(
                           *donor_progress)
                     : 0,
      filter_relocate_shards);
}

struct Set FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SHARDS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ShardInfo>> *shards() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ShardInfo>> *>(VT_SHARDS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SHARDS) &&
           verifier.Verify(shards()) &&
           verifier.VerifyVectorOfTables(shards()) &&
           verifier.EndTable();
  }
};

struct SetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shards(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShardInfo>>> shards) { fbb_.AddOffset(Set::VT_SHARDS, shards); }
  SetBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SetBuilder &operator=(const SetBuilder &);
  flatbuffers::Offset<Set> Finish() {
    auto o = flatbuffers::Offset<Set>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Set> CreateSet(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ShardInfo>>> shards = 0) {
  SetBuilder builder_(_fbb);
  builder_.add_shards(shards);
  return builder_.Finish();
}

inline flatbuffers::Offset<Set> CreateSetDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ShardInfo>> *shards = nullptr) {
  return CreateSet(_fbb, shards ? _fbb.CreateVector<flatbuffers::Offset<ShardInfo>>(*shards) : 0);
}

inline const facebook::logdevice::event_log_rebuilding_set::Set *GetSet(const void *buf) {
  return flatbuffers::GetRoot<facebook::logdevice::event_log_rebuilding_set::Set>(buf);
}

inline bool VerifySetBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<facebook::logdevice::event_log_rebuilding_set::Set>(nullptr);
}

inline void FinishSetBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<facebook::logdevice::event_log_rebuilding_set::Set> root) {
  fbb.Finish(root);
}

}  // namespace event_log_rebuilding_set
}  // namespace logdevice
}  // namespace facebook

#endif  // FLATBUFFERS_GENERATED_EVENTLOGREBUILDINGSET_FACEBOOK_LOGDEVICE_EVENT_LOG_REBUILDING_SET_H_
