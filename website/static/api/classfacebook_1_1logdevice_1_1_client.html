<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LogDevice API: facebook::logdevice::Client Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LogDevice API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefacebook.html">facebook</a></li><li class="navelem"><b>logdevice</b></li><li class="navelem"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classfacebook_1_1logdevice_1_1_client-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">facebook::logdevice::Client Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adb9de7dd7dc6db1b9b9dcca495a0d7b4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#adb9de7dd7dc6db1b9b9dcca495a0d7b4">Client</a> ()=default</td></tr>
<tr class="separator:adb9de7dd7dc6db1b9b9dcca495a0d7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f65fb0d14fe6a210a6001956a31b2a6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a7f65fb0d14fe6a210a6001956a31b2a6">~Client</a> ()=default</td></tr>
<tr class="separator:a7f65fb0d14fe6a210a6001956a31b2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038c93eefa0a8aa337b0c0b10970c7d0"><td class="memItemLeft" align="right" valign="top">virtual lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a038c93eefa0a8aa337b0c0b10970c7d0">appendSync</a> (logid_t logid, std::string payload, AppendAttributes attrs=AppendAttributes(), std::chrono::milliseconds *timestamp=nullptr) noexcept=0</td></tr>
<tr class="separator:a038c93eefa0a8aa337b0c0b10970c7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c9d8dafa223dce752752f96833ce7e"><td class="memItemLeft" align="right" valign="top">virtual lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a50c9d8dafa223dce752752f96833ce7e">appendSync</a> (logid_t logid, const Payload &amp;payload, AppendAttributes attrs=AppendAttributes(), std::chrono::milliseconds *timestamp=nullptr) noexcept=0</td></tr>
<tr class="separator:a50c9d8dafa223dce752752f96833ce7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadaa483f8ea0d2fc39d0eb3c5f65c09a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aadaa483f8ea0d2fc39d0eb3c5f65c09a">append</a> (logid_t logid, std::string payload, append_callback_t cb, AppendAttributes attrs=AppendAttributes()) noexcept=0</td></tr>
<tr class="separator:aadaa483f8ea0d2fc39d0eb3c5f65c09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91988929326118a897b33f0be79cde3b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a91988929326118a897b33f0be79cde3b">append</a> (logid_t logid, const Payload &amp;payload, append_callback_t cb, AppendAttributes attrs=AppendAttributes()) noexcept=0</td></tr>
<tr class="separator:a91988929326118a897b33f0be79cde3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797d6ebcb95ace4b95a198a293215103"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classfacebook_1_1logdevice_1_1_reader.html">Reader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a797d6ebcb95ace4b95a198a293215103">createReader</a> (size_t max_logs, ssize_t buffer_size=-1) noexcept=0</td></tr>
<tr class="separator:a797d6ebcb95ace4b95a198a293215103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527b0195263e113ad1d98a59d85bb8cd"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a527b0195263e113ad1d98a59d85bb8cd">createAsyncReader</a> (ssize_t buffer_size=-1) noexcept=0</td></tr>
<tr class="separator:a527b0195263e113ad1d98a59d85bb8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b30b82b19b71acd383c3f2fdbf321aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a2b30b82b19b71acd383c3f2fdbf321aa">setTimeout</a> (std::chrono::milliseconds timeout) noexcept=0</td></tr>
<tr class="separator:a2b30b82b19b71acd383c3f2fdbf321aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01eb0f0c77e1c55ad2958a05aad4bdc3"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a01eb0f0c77e1c55ad2958a05aad4bdc3">trimSync</a> (logid_t logid, lsn_t lsn) noexcept=0</td></tr>
<tr class="separator:a01eb0f0c77e1c55ad2958a05aad4bdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dbf28a3fc8266e4662a71deb73c21a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a51dbf28a3fc8266e4662a71deb73c21a">trim</a> (logid_t logid, lsn_t lsn, trim_callback_t cb) noexcept=0</td></tr>
<tr class="separator:a51dbf28a3fc8266e4662a71deb73c21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2363408b3b4c928cac60845cbe31d05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ab2363408b3b4c928cac60845cbe31d05">addWriteToken</a> (std::string) noexcept=0</td></tr>
<tr class="separator:ab2363408b3b4c928cac60845cbe31d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a04ef35610e51a47c3160e3e3b452bf"><td class="memItemLeft" align="right" valign="top">virtual lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a2a04ef35610e51a47c3160e3e3b452bf">findTimeSync</a> (logid_t logid, std::chrono::milliseconds timestamp, Status *status_out=nullptr, FindKeyAccuracy accuracy=FindKeyAccuracy::STRICT) noexcept=0</td></tr>
<tr class="separator:a2a04ef35610e51a47c3160e3e3b452bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42189ee10063b1917555aa83799c82f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structfacebook_1_1logdevice_1_1_find_key_result.html">FindKeyResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ab42189ee10063b1917555aa83799c82f">findKeySync</a> (logid_t logid, std::string key, FindKeyAccuracy accuracy=FindKeyAccuracy::STRICT) noexcept=0</td></tr>
<tr class="separator:ab42189ee10063b1917555aa83799c82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0c38ddae87c659ff68bbea760f020b"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a1e0c38ddae87c659ff68bbea760f020b">findTime</a> (logid_t logid, std::chrono::milliseconds timestamp, find_time_callback_t cb, FindKeyAccuracy accuracy=FindKeyAccuracy::STRICT) noexcept=0</td></tr>
<tr class="separator:a1e0c38ddae87c659ff68bbea760f020b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d954a3bca85a3b41ffd23600463cfcb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a4d954a3bca85a3b41ffd23600463cfcb">findKey</a> (logid_t logid, std::string key, find_key_callback_t cb, FindKeyAccuracy accuracy=FindKeyAccuracy::STRICT) noexcept=0</td></tr>
<tr class="separator:a4d954a3bca85a3b41ffd23600463cfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea7b4e3a8830fd9b7161470fce43f25"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#acea7b4e3a8830fd9b7161470fce43f25">isLogEmptySync</a> (logid_t logid, bool *empty) noexcept=0</td></tr>
<tr class="separator:acea7b4e3a8830fd9b7161470fce43f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa402ed205a3138575644c8b3e9e6df85"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aa402ed205a3138575644c8b3e9e6df85">isLogEmpty</a> (logid_t logid, is_empty_callback_t cb) noexcept=0</td></tr>
<tr class="separator:aa402ed205a3138575644c8b3e9e6df85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c058bc9b12472e46ce95d77f32a0b2c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a2c058bc9b12472e46ce95d77f32a0b2c">dataSizeSync</a> (logid_t logid, std::chrono::milliseconds start, std::chrono::milliseconds end, DataSizeAccuracy accuracy, size_t *size) noexcept=0</td></tr>
<tr class="separator:a2c058bc9b12472e46ce95d77f32a0b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19a0efc76f548b493957873002c1c15"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#af19a0efc76f548b493957873002c1c15">dataSize</a> (logid_t logid, std::chrono::milliseconds start, std::chrono::milliseconds end, DataSizeAccuracy accuracy, data_size_callback_t cb) noexcept=0</td></tr>
<tr class="separator:af19a0efc76f548b493957873002c1c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f426c780bd844dcc55114bf3a9b4c5f"><td class="memItemLeft" align="right" valign="top">virtual lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a1f426c780bd844dcc55114bf3a9b4c5f">getTailLSNSync</a> (logid_t logid) noexcept=0</td></tr>
<tr class="separator:a1f426c780bd844dcc55114bf3a9b4c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5854411762db40e48ba2e74142297c2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ae5854411762db40e48ba2e74142297c2">getTailLSN</a> (logid_t logid, get_tail_lsn_callback_t cb) noexcept=0</td></tr>
<tr class="separator:ae5854411762db40e48ba2e74142297c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a487dfa98c0d77fe35980f5392abbf4"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; LogTailAttributes &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a5a487dfa98c0d77fe35980f5392abbf4">getTailAttributesSync</a> (logid_t logid) noexcept=0</td></tr>
<tr class="separator:a5a487dfa98c0d77fe35980f5392abbf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a148372b0049445d9b63b06d5ac0d7613"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a148372b0049445d9b63b06d5ac0d7613">getTailAttributes</a> (logid_t logid, get_tail_attributes_callback_t cb) noexcept=0</td></tr>
<tr class="separator:a148372b0049445d9b63b06d5ac0d7613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcc4915bb41bfd3b97bf2de51584967"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; LogHeadAttributes &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a0bcc4915bb41bfd3b97bf2de51584967">getHeadAttributesSync</a> (logid_t logid) noexcept=0</td></tr>
<tr class="separator:a0bcc4915bb41bfd3b97bf2de51584967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff4a519d6313dc122468b0ab84a6cbc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a3ff4a519d6313dc122468b0ab84a6cbc">getHeadAttributes</a> (logid_t logid, get_head_attributes_callback_t cb) noexcept=0</td></tr>
<tr class="separator:a3ff4a519d6313dc122468b0ab84a6cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4d2aabc1842a955534ba9f215a44592"><td class="memItemLeft" align="right" valign="top">virtual logid_range_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ac4d2aabc1842a955534ba9f215a44592">getLogRangeByName</a> (const std::string &amp;name) noexcept=0</td></tr>
<tr class="separator:ac4d2aabc1842a955534ba9f215a44592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea15cbb86362e2c444bb52a3b130fce3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aea15cbb86362e2c444bb52a3b130fce3">getLogRangeByName</a> (const std::string &amp;name, get_log_range_by_name_callback_t cb) noexcept=0</td></tr>
<tr class="separator:aea15cbb86362e2c444bb52a3b130fce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e29c336be53be4381ea32a7e2a677fa"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a5e29c336be53be4381ea32a7e2a677fa">getLogNamespaceDelimiter</a> () noexcept=0</td></tr>
<tr class="separator:a5e29c336be53be4381ea32a7e2a677fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0817e65400f859da5f8c540d445d2a4f"><td class="memItemLeft" align="right" valign="top">virtual std::map&lt; std::string, logid_range_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a0817e65400f859da5f8c540d445d2a4f">getLogRangesByNamespace</a> (const std::string &amp;ns) noexcept=0</td></tr>
<tr class="separator:a0817e65400f859da5f8c540d445d2a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e735441fafb4528afdbee9573cf371f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a9e735441fafb4528afdbee9573cf371f">getLogRangesByNamespace</a> (const std::string &amp;ns, get_log_ranges_by_namespace_callback_t cb) noexcept=0</td></tr>
<tr class="separator:a9e735441fafb4528afdbee9573cf371f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b836b639eacf5f737fbee3246ae78f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; client::LogGroup &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aa6b836b639eacf5f737fbee3246ae78f">getLogGroupSync</a> (const std::string &amp;path) noexcept=0</td></tr>
<tr class="separator:aa6b836b639eacf5f737fbee3246ae78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2bf5451fc1e3415681271b64de0bfe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aab2bf5451fc1e3415681271b64de0bfe">getLogGroup</a> (const std::string &amp;path, get_log_group_callback_t cb) noexcept=0</td></tr>
<tr class="separator:aab2bf5451fc1e3415681271b64de0bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac000efd4c5f40b2836e13b4ce8b5e94b"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; client::LogGroup &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ac000efd4c5f40b2836e13b4ce8b5e94b">getLogGroupByIdSync</a> (const logid_t logid) noexcept=0</td></tr>
<tr class="separator:ac000efd4c5f40b2836e13b4ce8b5e94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d41ef80f8fc732ccd633efddfad96cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a0d41ef80f8fc732ccd633efddfad96cc">getLogGroupById</a> (const logid_t logid, get_log_group_callback_t cb) noexcept=0</td></tr>
<tr class="separator:a0d41ef80f8fc732ccd633efddfad96cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bbf9403fb51a73c2124e55fb97d0f4"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a70bbf9403fb51a73c2124e55fb97d0f4">makeDirectory</a> (const std::string &amp;path, bool mk_intermediate_dirs, const client::LogAttributes &amp;attrs, make_directory_callback_t cb) noexcept=0</td></tr>
<tr class="separator:a70bbf9403fb51a73c2124e55fb97d0f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553df78853ca09da72c8c090ab1904f9"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; client::Directory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a553df78853ca09da72c8c090ab1904f9">makeDirectorySync</a> (const std::string &amp;path, bool mk_intermediate_dirs=false, const client::LogAttributes &amp;attrs=client::LogAttributes(), std::string *failure_reason=nullptr) noexcept=0</td></tr>
<tr class="separator:a553df78853ca09da72c8c090ab1904f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1697b6688a972f991a05c706bdcecdf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aa1697b6688a972f991a05c706bdcecdf">removeDirectory</a> (const std::string &amp;path, bool recursive, status_callback_t) noexcept=0</td></tr>
<tr class="separator:aa1697b6688a972f991a05c706bdcecdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56747c28caeca0476ad42495cd2d00ca"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a56747c28caeca0476ad42495cd2d00ca">removeDirectorySync</a> (const std::string &amp;path, bool recursive=false) noexcept=0</td></tr>
<tr class="separator:a56747c28caeca0476ad42495cd2d00ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2c5b528fdeca565cb837d2e307df34"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a1a2c5b528fdeca565cb837d2e307df34">removeLogGroupSync</a> (const std::string &amp;path) noexcept=0</td></tr>
<tr class="separator:a1a2c5b528fdeca565cb837d2e307df34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f09c107d0083cf3e23538dca8b430bb"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a0f09c107d0083cf3e23538dca8b430bb">removeLogGroup</a> (const std::string &amp;path, status_callback_t cb) noexcept=0</td></tr>
<tr class="separator:a0f09c107d0083cf3e23538dca8b430bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3bcf709656e91fc65a82ee32e6634c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a9c3bcf709656e91fc65a82ee32e6634c">rename</a> (const std::string &amp;from_path, const std::string &amp;to_path, status_callback_t cb) noexcept=0</td></tr>
<tr class="separator:a9c3bcf709656e91fc65a82ee32e6634c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea81d5b164611e4da5a6878458b51e0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#adea81d5b164611e4da5a6878458b51e0">renameSync</a> (const std::string &amp;from_path, const std::string &amp;to_path, std::string *failure_reason=nullptr) noexcept=0</td></tr>
<tr class="separator:adea81d5b164611e4da5a6878458b51e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d99be796b2bdba8e9da20b08b04719"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#af5d99be796b2bdba8e9da20b08b04719">makeLogGroup</a> (const std::string &amp;path, const logid_range_t &amp;range, const client::LogAttributes &amp;attrs, bool mk_intermediate_dirs, make_log_group_callback_t cb) noexcept=0</td></tr>
<tr class="separator:af5d99be796b2bdba8e9da20b08b04719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54632fc9babcbe30d475e2da23f914f6"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; client::LogGroup &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a54632fc9babcbe30d475e2da23f914f6">makeLogGroupSync</a> (const std::string &amp;path, const logid_range_t &amp;range, const client::LogAttributes &amp;attrs=client::LogAttributes(), bool mk_intermediate_dirs=false, std::string *failure_reason=nullptr) noexcept=0</td></tr>
<tr class="separator:a54632fc9babcbe30d475e2da23f914f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771e6e5420f578bac83c51da04c878c2"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a771e6e5420f578bac83c51da04c878c2">setAttributes</a> (const std::string &amp;path, const client::LogAttributes &amp;attrs, status_callback_t cb) noexcept=0</td></tr>
<tr class="separator:a771e6e5420f578bac83c51da04c878c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1692d455a2c608dbcecd675123338c7a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a1692d455a2c608dbcecd675123338c7a">setAttributesSync</a> (const std::string &amp;path, const client::LogAttributes &amp;attrs, std::string *failure_reason=nullptr) noexcept=0</td></tr>
<tr class="separator:a1692d455a2c608dbcecd675123338c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef92340ce40a5f12b0e9b685595145a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aaef92340ce40a5f12b0e9b685595145a">setLogGroupRange</a> (const std::string &amp;path, const logid_range_t &amp;range, status_callback_t) noexcept=0</td></tr>
<tr class="separator:aaef92340ce40a5f12b0e9b685595145a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c94850b340bcc37cda74f35f9183d0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ab7c94850b340bcc37cda74f35f9183d0">setLogGroupRangeSync</a> (const std::string &amp;path, const logid_range_t &amp;range, std::string *failure_reason=nullptr) noexcept=0</td></tr>
<tr class="separator:ab7c94850b340bcc37cda74f35f9183d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2b8650e686d6165f1d5a7945d63996"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a2c2b8650e686d6165f1d5a7945d63996">getDirectory</a> (const std::string &amp;path, get_directory_callback_t) noexcept=0</td></tr>
<tr class="separator:a2c2b8650e686d6165f1d5a7945d63996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267a0614cc5e63a390251b028d4bae5f"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; client::Directory &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a267a0614cc5e63a390251b028d4bae5f">getDirectorySync</a> (const std::string &amp;path) noexcept=0</td></tr>
<tr class="separator:a267a0614cc5e63a390251b028d4bae5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c95d7cb5a1ad1951f4fb2ad292a325"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a34c95d7cb5a1ad1951f4fb2ad292a325">syncLogsConfigVersion</a> (uint64_t version) noexcept=0</td></tr>
<tr class="separator:a34c95d7cb5a1ad1951f4fb2ad292a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9828b92a8b696b1649b515f1fb157547"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classfacebook_1_1logdevice_1_1_config_subscription_handle.html">ConfigSubscriptionHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a9828b92a8b696b1649b515f1fb157547">notifyOnLogsConfigVersion</a> (uint64_t version, std::function&lt; void()&gt;) noexcept=0</td></tr>
<tr class="separator:a9828b92a8b696b1649b515f1fb157547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef7b6cbbef31366b14cec7a578e80bb9"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; ClusterAttributes &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aef7b6cbbef31366b14cec7a578e80bb9">getClusterAttributes</a> () noexcept=0</td></tr>
<tr class="separator:aef7b6cbbef31366b14cec7a578e80bb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5189e872667a158b8837da87185ab7ec"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classfacebook_1_1logdevice_1_1_config_subscription_handle.html">ConfigSubscriptionHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a5189e872667a158b8837da87185ab7ec">subscribeToConfigUpdates</a> (config_update_callback_t) noexcept=0</td></tr>
<tr class="separator:a5189e872667a158b8837da87185ab7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977eec4108a9f539d539b2cae820c247"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a977eec4108a9f539d539b2cae820c247">getMaxPayloadSize</a> () noexcept=0</td></tr>
<tr class="separator:a977eec4108a9f539d539b2cae820c247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa91f8e42039d4f7606d1c7668f37ea"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classfacebook_1_1logdevice_1_1_client_settings.html">ClientSettings</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aafa91f8e42039d4f7606d1c7668f37ea">settings</a> ()=0</td></tr>
<tr class="separator:aafa91f8e42039d4f7606d1c7668f37ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57471fa5b9d0641343e9a5f07e79da20"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a57471fa5b9d0641343e9a5f07e79da20">getAllReadStreamsDebugInfo</a> () noexcept=0</td></tr>
<tr class="separator:a57471fa5b9d0641343e9a5f07e79da20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e0bcb6f9dabd95d40b1b63a98448ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ab8e0bcb6f9dabd95d40b1b63a98448ab">publishEvent</a> (Severity sev, std::string name_space, std::string type, std::string data=&quot;&quot;, std::string context=&quot;&quot;) noexcept=0</td></tr>
<tr class="separator:ab8e0bcb6f9dabd95d40b1b63a98448ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a22c6047d80ec6b513bef7d61883f0bb4"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a22c6047d80ec6b513bef7d61883f0bb4">create</a> (std::string cluster_name, std::string config_url, std::string credentials, std::chrono::milliseconds timeout, std::unique_ptr&lt; <a class="el" href="classfacebook_1_1logdevice_1_1_client_settings.html">ClientSettings</a> &gt; <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aafa91f8e42039d4f7606d1c7668f37ea">settings</a>, std::string csid=&quot;&quot;) noexcept</td></tr>
<tr class="separator:a22c6047d80ec6b513bef7d61883f0bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adb9de7dd7dc6db1b9b9dcca495a0d7b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9de7dd7dc6db1b9b9dcca495a0d7b4">&#9670;&nbsp;</a></span>Client()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">facebook::logdevice::Client::Client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>No default constructor will issue a compilation error, since ClientImpl need to initialize the <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> object at first. </p>

</div>
</div>
<a id="a7f65fb0d14fe6a210a6001956a31b2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f65fb0d14fe6a210a6001956a31b2a6">&#9670;&nbsp;</a></span>~Client()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual facebook::logdevice::Client::~Client </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a22c6047d80ec6b513bef7d61883f0bb4">create()</a> actually returns pointers to objects of class ClientImpl that inherits from <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a>. The destructor must be virtual in order to work correctly. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab2363408b3b4c928cac60845cbe31d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2363408b3b4c928cac60845cbe31d05">&#9670;&nbsp;</a></span>addWriteToken()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::Client::addWriteToken </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Supply a write token. Without this, writes to any logs configured to require a write token will fail.</p>
<p>Write tokens are a safety feature intended to reduce the risk of accidentally writing into the wrong log, particularly in multitenant deployments. </p>

</div>
</div>
<a id="aadaa483f8ea0d2fc39d0eb3c5f65c09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadaa483f8ea0d2fc39d0eb3c5f65c09a">&#9670;&nbsp;</a></span>append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::append </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">append_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AppendAttributes&#160;</td>
          <td class="paramname"><em>attrs</em> = <code>AppendAttributes()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends a new record to the log without blocking. The function returns control to caller as soon as the append request is put on a delivery queue in this process' address space. The LogDevice client library will call a callback on an unspecified thread when the operation completes.</p>
<p>NOTE: records appended to the same log by calling <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aadaa483f8ea0d2fc39d0eb3c5f65c09a">append()</a> method of the same <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> object on the same thread are guaranteed to receive sequence numbers in the order the <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aadaa483f8ea0d2fc39d0eb3c5f65c09a">append()</a> calls were made. That is, if both appends succeed, the sequence number assigned to the record sent earler will be smaller than the sequence number assigned to the later record.</p>
<p>This is not always true for a pair of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aadaa483f8ea0d2fc39d0eb3c5f65c09a">append()</a> calls on the same log made by <em>different</em> threads or through <em>different</em> <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> objects. In those cases internal buffering in various LogDevice client and server components may result in the record in an earlier <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aadaa483f8ea0d2fc39d0eb3c5f65c09a">append()</a> call to receive a higher sequence number than the one submitted by a later <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aadaa483f8ea0d2fc39d0eb3c5f65c09a">append()</a> call made by a different thread or process, or made through a different <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">logdevice::Client</a> object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>unique id of the log to which to append a new record</td></tr>
    <tr><td class="paramname">payload</td><td>record payload.</td></tr>
    <tr><td class="paramname">cb</td><td>the callback to call</td></tr>
    <tr><td class="paramname">attrs</td><td>additional append attributes. See AppendAttributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned if the request was successfully enqueued for delivery. On failure -1 is returned and logdevice::err is set to TOOBIG if payload is too big (see <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a977eec4108a9f539d539b2cae820c247">Client::getMaxPayloadSize()</a>) NOBUFS if request could not be enqueued because a buffer space limit was reached INVALID_PARAM logid is invalid </dd></dl>

</div>
</div>
<a id="a91988929326118a897b33f0be79cde3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91988929326118a897b33f0be79cde3b">&#9670;&nbsp;</a></span>append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::append </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Payload &amp;&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">append_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AppendAttributes&#160;</td>
          <td class="paramname"><em>attrs</em> = <code>AppendAttributes()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends a new record to the log without blocking. This version doesn't transfer the ownership of the payload to LogDevice and assumes that the caller will be responsible for destroying it.</p>
<p>IMPORTANT: for performance reasons this function does not make an internal copy of payload. It just passes payload.data pointer and payload.size value to the LogDevice client thread pool. The caller MUST make sure that the payload is not free'd or modified, or its memory is otherwise reused until the callback cb() is called with the same payload as its argument. A common pattern for sending a payload that's on the stack is to memcpy() it into a malloc'ed buffer, then call free() on payload.data pointer passed to cb(). </p>

</div>
</div>
<a id="a038c93eefa0a8aa337b0c0b10970c7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038c93eefa0a8aa337b0c0b10970c7d0">&#9670;&nbsp;</a></span>appendSync() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual lsn_t facebook::logdevice::Client::appendSync </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AppendAttributes&#160;</td>
          <td class="paramname"><em>attrs</em> = <code>AppendAttributes()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds *&#160;</td>
          <td class="paramname"><em>timestamp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends a new record to the log. Blocks until operation completes. The delivery of a signal does not interrupt the wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>unique id of the log to which to append a new record</td></tr>
    <tr><td class="paramname">payload</td><td>record payload</td></tr>
    <tr><td class="paramname">attrs</td><td>additional append attributes. See AppendAttributes</td></tr>
    <tr><td class="paramname">timestamp</td><td>Timestamp set and stored with the record by the LogDevice cluster.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success the sequence number (LSN) of new record is returned. On failure LSN_INVALID is returned and logdevice::err is set to one of: TIMEDOUT timeout expired before operation status was known. The record may or may not be appended. The timeout used is from this <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> object. NOTFOUND The logid was not found in the config.</dd></dl>
<p>NOTINSERVERCONFIG The logid was not found in the config of the seqeuncer node</p>
<p>NOSEQUENCER The client has been unable to locate a sequencer for this log. For example, the server that was previously sequencing this log has crashed or is shutting down, and a replacement has not yet been brought up, or its identity has not yet been communicated to this client. CONNFAILED Failed to connect to sequencer. Request was not sent. Possible reasons:</p><ul>
<li>invalid address in cluster config</li>
<li>logdeviced running the sequencer is down or unreachable</li>
<li>mismatching cluster name between client and sequencer</li>
<li>mismatching destination and receiving node ids PEER_CLOSED Sequencer closed connection after we sent the append request but before we got a reply. Record may or may not be appended. TOOBIG Payload is too big (see <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a977eec4108a9f539d539b2cae820c247">Client::getMaxPayloadSize()</a>) NOBUFS request could not be enqueued because a buffer space limit was reached in this <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> object. Request was not sent SYSLIMIT client process has reached a system limit on resources, such as file descriptors, ephemeral ports, or memory. Request was not sent. SEQNOBUFS sequencer is out of buffer space for this log. Record was not appended. SEQSYSLIMIT sequencer has reached a file descriptor limit, the maximum number of ephemeral ports, or some other system limit. Record may or may not be appended. NOSPC too many nodes on the storage cluster have run out of free disk space. Record was not appended. OVERLOADED too many nodes on the storage cluster are overloaded. Record was not appended. DISABLED too many nodes on the storage cluster are in error state or rebuilding. Record was not appended. ACCESS the service denied access to this client based on credentials presented SHUTDOWN the <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">logdevice::Client</a> instance was destroyed. Request was not sent. INTERNAL an internal error has been detected, check logs INVALID_PARAM logid is invalid BADPAYLOAD the checksum bits do not correspond with the Payload data. In this case the record is not appended. CANCELLED the appender cancelled the request due to some conditions on server side, such as for instance it detected that the record may have been stored in a previous epoch (a.k.a silent duplicate) PEER_UNAVAILABLE the sequencer died or became unresponsive. the record may or may not have been appended. </li>
</ul>

</div>
</div>
<a id="a50c9d8dafa223dce752752f96833ce7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c9d8dafa223dce752752f96833ce7e">&#9670;&nbsp;</a></span>appendSync() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual lsn_t facebook::logdevice::Client::appendSync </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Payload &amp;&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AppendAttributes&#160;</td>
          <td class="paramname"><em>attrs</em> = <code>AppendAttributes()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds *&#160;</td>
          <td class="paramname"><em>timestamp</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends a new record to the log. Blocks until operation completes. The delivery of a signal does not interrupt the wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>unique id of the log to which to append a new record</td></tr>
    <tr><td class="paramname">payload</td><td>record payload, see Record.h. The function does not make an internal copy of payload. Other threads of the caller must not modify payload data until the call returns.</td></tr>
    <tr><td class="paramname">attrs</td><td>additional append attributes. See AppendAttributes</td></tr>
    <tr><td class="paramname">timestamp</td><td>Timestamp set and stored with the record by the LogDevice cluster.</td></tr>
  </table>
  </dd>
</dl>
<p>See appendSync(logid_t, const Payload&amp;) for a description of return values. </p>

</div>
</div>
<a id="a22c6047d80ec6b513bef7d61883f0bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c6047d80ec6b513bef7d61883f0bb4">&#9670;&nbsp;</a></span>create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a>&gt; facebook::logdevice::Client::create </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>cluster_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>config_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>credentials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classfacebook_1_1logdevice_1_1_client_settings.html">ClientSettings</a> &gt;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>csid</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is the only way to create new <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> instances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cluster_name</td><td>name of the LogDevice cluster to connect to </td></tr>
    <tr><td class="paramname">config_url</td><td>a URL that identifies at a LogDevice configuration resource (such as a file) describing the LogDevice cluster this client will talk to. The only supported formats are currently file:&lt;path-to-configuration-file&gt; and configerator:&lt;configerator-path&gt;. Examples: "file:logdevice.test.conf" "configerator:logdevice/logdevice.test.conf" </td></tr>
    <tr><td class="paramname">credentials</td><td>credentials specification. This may include credentials to present to the LogDevice cluster along with authentication and encryption specifiers. </td></tr>
    <tr><td class="paramname">timeout</td><td>construction timeout. This value also serves as the default timeout for methods on the created object </td></tr>
    <tr><td class="paramname">settings</td><td>client settings instance to take ownership of, or nullptr for default settings. See <a class="el" href="_client_settings_8h_source.html">ClientSettings.h</a> for a list of commonly used settings. </td></tr>
    <tr><td class="paramname">csid</td><td>CSID (<a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> Session ID). Used for logging to uniquely identify session. If csid is empty, random one is generated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>on success, a fully constructed LogDevice client object for the specified LogDevice cluster. On failure nullptr is returned and logdevice::err is set to INVALID_PARAM invalid config URL, cluster name or credentials is too log. TIMEDOUT timed out while trying to get config FILE_OPEN config file could not be opened FILE_READ error reading config file INVALID_CONFIG various errors in parsing the config SYSLIMIT monitoring thread for the config could not be started </dd></dl>

</div>
</div>
<a id="a527b0195263e113ad1d98a59d85bb8cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527b0195263e113ad1d98a59d85bb8cd">&#9670;&nbsp;</a></span>createAsyncReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a>&gt; facebook::logdevice::Client::createAsyncReader </td>
          <td>(</td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a> object that can be used to read from one or more logs via callbacks. </p>

</div>
</div>
<a id="a797d6ebcb95ace4b95a198a293215103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797d6ebcb95ace4b95a198a293215103">&#9670;&nbsp;</a></span>createReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classfacebook_1_1logdevice_1_1_reader.html">Reader</a>&gt; facebook::logdevice::Client::createReader </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_logs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ssize_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classfacebook_1_1logdevice_1_1_reader.html">Reader</a> object that can be used to read from one or more logs.</p>
<p>Approximate memory usage when reading is: max_logs * client_read_buffer_size * (24*F + C + avg_record_size) bytes</p>
<p>The constant F is between 1 and 2 depending on the client_read_flow_control_threshold setting. The constant C is ClientReadStream overhead, probably a few pointers.</p>
<p>When reading many logs, or when memory is important, the client read buffer size can be reduced (before creating the <a class="el" href="classfacebook_1_1logdevice_1_1_reader.html">Reader</a>) from the default 4096:</p>
<p>int rv = client-&gt;<a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aafa91f8e42039d4f7606d1c7668f37ea">settings()</a>.set("client-read-buffer-size", 128); assert(rv == 0);</p>
<p>The client can also set its individual buffer size via the optional buffer_size parameter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_logs</td><td>maximum number of logs that can be read from this <a class="el" href="classfacebook_1_1logdevice_1_1_reader.html">Reader</a> at the same time </td></tr>
    <tr><td class="paramname">buffer_size</td><td>specify the read buffer size for this client, fallback to the value in settings if it is -1 or omitted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af19a0efc76f548b493957873002c1c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19a0efc76f548b493957873002c1c15">&#9670;&nbsp;</a></span>dataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::dataSize </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataSizeAccuracy&#160;</td>
          <td class="paramname"><em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">data_size_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NOTE: this is currently a dummy API that will always return 0; please refrain from using other than for testing.</p>
<p>A non-blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a2a04ef35610e51a47c3160e3e3b452bf">findTimeSync()</a>. Calllback will be called with one of the error codes mentioned regarding return in findTimeSync, with the addition of E::OK for successful requests.</p>
<dl class="section return"><dt>Returns</dt><dd>If the request was successfully submitted for processing, returns 0. In that case, the supplied callback is guaranteed to be called at a later time with the outcome of the request. See <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a2c058bc9b12472e46ce95d77f32a0b2c">dataSizeSync()</a> for documentation of possible results. Otherwise, returns -1 with the error:<ul>
<li>E::NOBUFS: Too many requests were pending to be delivered to Workers. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2c058bc9b12472e46ce95d77f32a0b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c058bc9b12472e46ce95d77f32a0b2c">&#9670;&nbsp;</a></span>dataSizeSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::dataSizeSync </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DataSizeAccuracy&#160;</td>
          <td class="paramname"><em>accuracy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NOTE: this is currently a dummy API that will always return 0; please refrain from using other than for testing.</p>
<p>Finds the size of stored data for the given log in the given time range, with accuracy as requested. Please note: this is post-batching and compression; the size will likely be larger to a reader. This method is blocking until the size has been determined or an error occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>ID of the log to examine </td></tr>
    <tr><td class="paramname">start</td><td>start of the range we want to find the size of </td></tr>
    <tr><td class="paramname">end</td><td>end of the range we want to find the size of </td></tr>
    <tr><td class="paramname">accuracy</td><td>specifies the desired accuracy; higher accuracy means the operation will be slower and less efficient. Accuracy can be: APPROXIMATE In this case, uses findTime to get the LSN boundaries of the range we want to find the size of. On any partitions which are partially covered by this range, dataSize will approximate the size usage by linear interpolation. The size of partitions is affected largely by partition-duration and partition-size-limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 and sets size appropriately if the operation succeeded; if an error was encountered, returns -1 and sets err to one of the following:<ul>
<li>E::ACCESS Permission to access the log was denied</li>
<li>E::PARTIAL: Only part of the cluster responded and we only got an approximate answer. The size of the data in the range should be expected to be greater than the answer given.</li>
<li>E::FAILED: No storage nodes responded, or another critical failure.</li>
<li>E::SHUTDOWN: <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> was destroyed while the request was processing.</li>
</ul>
</dd></dl>
<p>NOTE While this is a dummy API, possible err values are subject to change. </p>

</div>
</div>
<a id="a4d954a3bca85a3b41ffd23600463cfcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d954a3bca85a3b41ffd23600463cfcb">&#9670;&nbsp;</a></span>findKey()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::findKey </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">find_key_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FindKeyAccuracy&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>FindKeyAccuracy::STRICT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A non-blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ab42189ee10063b1917555aa83799c82f">findKeySync()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>If the request was successfully submitted for processing, returns 0. In that case, the supplied callback is guaranteed to be called at a later time with the outcome of the request. See <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ab42189ee10063b1917555aa83799c82f">findKeySync()</a> for documentation for the result. Otherwise, returns -1. </dd></dl>

</div>
</div>
<a id="ab42189ee10063b1917555aa83799c82f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42189ee10063b1917555aa83799c82f">&#9670;&nbsp;</a></span>findKeySync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structfacebook_1_1logdevice_1_1_find_key_result.html">FindKeyResult</a> facebook::logdevice::Client::findKeySync </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FindKeyAccuracy&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>FindKeyAccuracy::STRICT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the sequence number corresponding to the record with the given key for the log.</p>
<p>The result provides two LSNs: the first one, lo, is the highest LSN with key smaller than the given key, the second one, hi, is the lowest LSN with key equal or greater than the given key. With accuracy parameter set to APPROXIMATE, the first LSN can be underestimated and the second LSN can be overestimated by a few minutes, in terms of record timestamps.</p>
<p>It is assumed that keys within the same log are monotonically non-decreasing (when compared lexicographically). If this is not true, the accuracy of this API may be affected.</p>
<p>The delivery of a signal does not interrupt the wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>ID of log to query </td></tr>
    <tr><td class="paramname">key</td><td>select the oldest record in this log whose key is greater or equal to <em>key</em>, for upper bound of result; select the newest record in this log whose key is smaller than <em>key</em>, for lower bound. </td></tr>
    <tr><td class="paramname">status_out</td><td>if this argument is nullptr, it is ignored. Otherwise, *status_out will hold the outcome of the request as described below. </td></tr>
    <tr><td class="paramname">accuracy</td><td>Accuracy option specifies how accurate the result of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a4d954a3bca85a3b41ffd23600463cfcb">findKey()</a> has to be. It allows to choose best accuracy-speed trade off for each specific use case. Accuracy can be: STRICT In this case <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a4d954a3bca85a3b41ffd23600463cfcb">findKey()</a> will do binary search over partitions in memory + search inside partition on disk. Result will be accurate but execution is slower than in APPROXIMATE mode. More precisely, this attempts to find the last LSN before the given key and the first LSN at or after the given key. However, if we cannot get a conclusive answer (system issues prevent us from getting answers from part of the cluster), this may return a slightly larger range (with an appropriate status as documented below). STRICT options is recommended if cluster has Flash disks set up. APPROXIMATE <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a4d954a3bca85a3b41ffd23600463cfcb">findKey()</a> will only perform binary search on the partition directory in order to find the partition whose minimum key in the directory is &lt;= given key and the partition after this one whose minimum key is &gt;= given key. Then it will return the corresponding LSNs of the two records. The record corresponding to the lower LSN can be several minutes older than the record given by the upper LSN, but execution will be faster than in STRICT mode. APPROXIMATE options is recommended if cluster has HDD disks set up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a <a class="el" href="structfacebook_1_1logdevice_1_1_find_key_result.html">FindKeyResult</a> struct with both lo and hi set to LSN_INVALID on complete failure or set to the values described above. The value of status can be inspected to determine the accuracy of the result:<ul>
<li>E::INVALID_PARAM: logid was invalid</li>
<li>E::OK: Enough of the cluster responded to produce a conclusive answer. Assuming monotonic keys, the result provides the LSNs lo and hi as described above.</li>
<li>E::ACCESS Permission to access the log was denied</li>
<li>E::PARTIAL: Only part of the cluster responded and we only got an approximate answer. Assuming monotonic keys, the result contains two LSNs representing a larger range than in the E::OK case.</li>
<li>E::FAILED: No storage nodes responded, or another critical failure.</li>
<li>E::SHUTDOWN: <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> was destroyed while the request was processing. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a1e0c38ddae87c659ff68bbea760f020b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0c38ddae87c659ff68bbea760f020b">&#9670;&nbsp;</a></span>findTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::findTime </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">find_time_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FindKeyAccuracy&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>FindKeyAccuracy::STRICT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A non-blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a2a04ef35610e51a47c3160e3e3b452bf">findTimeSync()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>If the request was successfully submitted for processing, returns 0. In that case, the supplied callback is guaranteed to be called at a later time with the outcome of the request. See <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a2a04ef35610e51a47c3160e3e3b452bf">findTimeSync()</a> for documentation for the result. Otherwise, returns -1 with the error:<ul>
<li>E::NOBUFS: Too many requests were pending to be delivered to Workers. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a2a04ef35610e51a47c3160e3e3b452bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a04ef35610e51a47c3160e3e3b452bf">&#9670;&nbsp;</a></span>findTimeSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual lsn_t facebook::logdevice::Client::findTimeSync </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timestamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Status *&#160;</td>
          <td class="paramname"><em>status_out</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FindKeyAccuracy&#160;</td>
          <td class="paramname"><em>accuracy</em> = <code>FindKeyAccuracy::STRICT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks for the sequence number that the log was at at the given time. The most common use case is to read all records since that time, by subsequently calling startReading(result_lsn).</p>
<p>The result lsn can be smaller than biggest lsn which timestamp is &lt;= given timestamp. With accuracy parameter set to APPROXIMATE this error can be several minutes. Note that even in that case startReading(result_lsn) will read all records at the given timestamp or later, but it may also read some earlier records.</p>
<p>If the given timestamp is earlier than all records in the log, this returns the LSN after the point to which the log was trimmed.</p>
<p>If the given timestamp is later than all records in the log, this returns the next sequence number to be issued. Calling startReading(result_lsn) will read newly written records.</p>
<p>If the log is empty, this returns LSN_OLDEST.</p>
<p>All of the above assumes that records in the log have increasing timestamps. If timestamps are not monotonic, the accuracy of this API may be affected. This may be the case if the sequencer's system clock is changed, or if the sequencer moves and the clocks are not in sync.</p>
<p>The delivery of a signal does not interrupt the wait.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>ID of log to query </td></tr>
    <tr><td class="paramname">timestamp</td><td>select the oldest record in this log whose timestamp is greater or equal to <em>timestamp</em>. </td></tr>
    <tr><td class="paramname">status_out</td><td>if this argument is nullptr, it is ignored. Otherwise, *status_out will hold the outcome of the request as described below. </td></tr>
    <tr><td class="paramname">accuracy</td><td>Accuracy option specify how accurate the result of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a1e0c38ddae87c659ff68bbea760f020b">findTime()</a> has to be. It allows to choose best accuracy-speed trade off for each specific use case. Accuracy can be: STRICT In this case <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a1e0c38ddae87c659ff68bbea760f020b">findTime()</a> will do binary search over partitions in memory + binary search inside partition on disk. Result will be accurate but execution is slower than in APPROXIMATE mode. More precisely, this attempts to find the first LSN at or after the given time. However, if we cannot get a conclusive answer (system issues prevent us from getting answers from part of the cluster), this may return a slightly earlier LSN (with an appropriate status as documented below). STRICT options is recommended if cluster has Flash disks set up. APPROXIMATE <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a1e0c38ddae87c659ff68bbea760f020b">findTime()</a> will only perform binary search on the partition directory in order to find the newest partition whose timestamp in the directory is &lt;= given timestamp. Then it will return first lsn of given log_id in this partition. The result lsn can be several minutes earlier than biggest lsn which timestamp is &lt;= given timestamp but execution will be faster than in STRICT mode. APPROXIMATE options is recommended if cluster has HDD disks set up.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns LSN_INVALID on complete failure or an LSN as described above. If status_out is not null, *status_out can be inspected to determine the accuracy of the result:<ul>
<li>E::OK: Enough of the cluster responded to produce a conclusive answer. Assuming monotonic timestamps, the returned LSN is exactly the first record at or after the given time.</li>
<li>E::INVALID_PARAM: <code>logid</code> is invalid or doesn't exist.</li>
<li>E::ACCESS Permission to access the log was denied</li>
<li>E::PARTIAL: Only part of the cluster responded and we only got an approximate answer. Assuming monotonic timestamps, the returned LSN is no later than any record at or after the given time.</li>
<li>E::FAILED: No storage nodes responded, or another critical failure.</li>
<li>E::SHUTDOWN: <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> was destroyed while the request was processing. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a57471fa5b9d0641343e9a5f07e79da20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57471fa5b9d0641343e9a5f07e79da20">&#9670;&nbsp;</a></span>getAllReadStreamsDebugInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string facebook::logdevice::Client::getAllReadStreamsDebugInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a string containing the state of all ClientReadStreams running on workers owned by this client. Used for debugging </dd></dl>

</div>
</div>
<a id="aef7b6cbbef31366b14cec7a578e80bb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef7b6cbbef31366b14cec7a578e80bb9">&#9670;&nbsp;</a></span>getClusterAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;ClusterAttributes&gt; facebook::logdevice::Client::getClusterAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exposes configuration attributes.</p>
<dl class="section return"><dt>Returns</dt><dd>ClusterAttributes object that contains attributes coming from the client's configuration </dd></dl>

</div>
</div>
<a id="a2c2b8650e686d6165f1d5a7945d63996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2b8650e686d6165f1d5a7945d63996">&#9670;&nbsp;</a></span>getDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::getDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">get_directory_callback_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all directories and LogGroupNode(s) under this path. Note that this will return the full tree if the dir_path equals the delimiter. e.g, dir_path = "/" will return the root directory with all children, recursively! </p>

</div>
</div>
<a id="a267a0614cc5e63a390251b028d4bae5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267a0614cc5e63a390251b028d4bae5f">&#9670;&nbsp;</a></span>getDirectorySync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;client::Directory&gt; facebook::logdevice::Client::getDirectorySync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a2c2b8650e686d6165f1d5a7945d63996">getDirectory()</a> </p>

</div>
</div>
<a id="a3ff4a519d6313dc122468b0ab84a6cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff4a519d6313dc122468b0ab84a6cbc">&#9670;&nbsp;</a></span>getHeadAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::getHeadAttributes </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">get_head_attributes_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A non-blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a0bcc4915bb41bfd3b97bf2de51584967">getHeadAttributesSync()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>is the ID of the log for which to get the tail attributes </td></tr>
    <tr><td class="paramname">cb</td><td>will be called once the tail attributes of the log are determined or an error occurred. The possible status values are the same as for <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a0bcc4915bb41bfd3b97bf2de51584967">getHeadAttributesSync()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfully scheduled, -1 otherwise. </dd></dl>

</div>
</div>
<a id="a0bcc4915bb41bfd3b97bf2de51584967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcc4915bb41bfd3b97bf2de51584967">&#9670;&nbsp;</a></span>getHeadAttributesSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;LogHeadAttributes&gt; facebook::logdevice::Client::getHeadAttributesSync </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return current attributes of the head of the log. See LogHeadAttributes.h docs about possible head attributes. The timestamp of the next record after trim point may be approximate. It allows to make request efficient. The error of approximation is limited by log append rate and should be negligible for high throughput logs. See GetHeadAttributesRequest.h doc block for more Implementation details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>is the ID of the log for which to get the tail attributes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to log head attributes (see LogHeadAttributes.h docs) if request executed with status E::OK. Otherwise returns nullptr and sets logdevice::err to: E::TIMEDOUT We could not get enough replies from a nodes in time. E::ACCESS permission to access the log was denied E::INVALID_PARAM Specified log is metadata log or invalid. E::SHUTDOWN: <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> was destroyed while the request was processing. E::FAILED Request failed. </dd></dl>

</div>
</div>
<a id="aab2bf5451fc1e3415681271b64de0bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2bf5451fc1e3415681271b64de0bfe">&#9670;&nbsp;</a></span>getLogGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::Client::getLogGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">get_log_group_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An async variant of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aab2bf5451fc1e3415681271b64de0bfe">getLogGroup()</a>. This can be called from async LogDevice callbacks safely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>callback that will be called on an unspecified thread with the result. The callback can be called before or after the call to <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aab2bf5451fc1e3415681271b64de0bfe">getLogGroup()</a> finishes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfuly scheduled, -1 otherwise. </dd></dl>

</div>
</div>
<a id="a0d41ef80f8fc732ccd633efddfad96cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d41ef80f8fc732ccd633efddfad96cc">&#9670;&nbsp;</a></span>getLogGroupById()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::Client::getLogGroupById </td>
          <td>(</td>
          <td class="paramtype">const logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">get_log_group_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An async variant of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ac000efd4c5f40b2836e13b4ce8b5e94b">getLogGroupByIdSync()</a>. This can be called from async LogDevice callbacks safely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>callback that will be called on an unspecified thread with the result. The callback can be called before or after the call to <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ac000efd4c5f40b2836e13b4ce8b5e94b">getLogGroupByIdSync()</a> finishes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfuly scheduled, -1 otherwise. sets err to one of: E::NOTFOUND the log group for this id does not exist E::TIMEDOUT Operation timed out. </dd></dl>

</div>
</div>
<a id="ac000efd4c5f40b2836e13b4ce8b5e94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac000efd4c5f40b2836e13b4ce8b5e94b">&#9670;&nbsp;</a></span>getLogGroupByIdSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;client::LogGroup&gt; facebook::logdevice::Client::getLogGroupByIdSync </td>
          <td>(</td>
          <td class="paramtype">const logid_t&#160;</td>
          <td class="paramname"><em>logid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks up metadata of a log group by its name as specified in this <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a>'s configuration.</p>
<p>Note: This synchronous method may not be called from a callback of an async LogDevice API. This is checked, asserted in debug builds, and causes requests in release builds to fail. The reason is that we would already be on an internal LogDevice thread, the request would need to be processed by an internal LogDevice thread, and having one wait for another could result in deadlock. Use the async version below.</p>
<dl class="section return"><dt>Returns</dt><dd>If configuration has a log with log_id </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid,returns</td><td>the LogGroup object that contains the attributes for that entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa6b836b639eacf5f737fbee3246ae78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6b836b639eacf5f737fbee3246ae78f">&#9670;&nbsp;</a></span>getLogGroupSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;client::LogGroup&gt; facebook::logdevice::Client::getLogGroupSync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks up metadata of a log group by its name as specified in this <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a>'s configuration.</p>
<p>Note: This synchronous method may not be called from a callback of an async LogDevice API. This is checked, asserted in debug builds, and causes requests in release builds to fail. The reason is that we would already be on an internal LogDevice thread, the request would need to be processed by an internal LogDevice thread, and having one wait for another could result in deadlock. Use the async version below.</p>
<dl class="section return"><dt>Returns</dt><dd>If configuration has a log with "name" attribute </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name,returns</td><td>the LogGroup object that contains the attributes for that entry. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e29c336be53be4381ea32a7e2a677fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e29c336be53be4381ea32a7e2a677fa">&#9670;&nbsp;</a></span>getLogNamespaceDelimiter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string facebook::logdevice::Client::getLogNamespaceDelimiter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the character that delimits namespaces when specifying a nested namespace hierarchy (see <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a0817e65400f859da5f8c540d445d2a4f">getLogRangesByNamespace()</a>). </p>

</div>
</div>
<a id="ac4d2aabc1842a955534ba9f215a44592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4d2aabc1842a955534ba9f215a44592">&#9670;&nbsp;</a></span>getLogRangeByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual logid_range_t facebook::logdevice::Client::getLogRangeByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks up the boundaries of a log range by its name as specified in this <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a>'s configuration.</p>
<p>If configuration has a JSON object in the "logs" section with "name" attribute </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>and without "layout" attribute, returns the lowest and highest log ids in the range. If a JSON object in the "logs" section has "layout" attribute with value "AxB", it produces A ranges, each of length 1, named "&lt;name&gt;", "&lt;name&gt;#1", "&lt;name&gt;#2", ..., "&lt;name&gt;#&lt;A-1&gt;", where &lt;name&gt; is the value of "name" attribute. Optionally, it is possible to extend the length of a particular range up to B by specifying pairs of the form &lt;num&gt;:&lt;size&gt; separated by commas, in the layout attribute, where &lt;num&gt; is the index of the range (starting at 0) and &lt;size&gt; is its length (within [0,B]). eg: "4x8 1:3,2:5" will produce 4 ranges of size, respectively, 1, 3, 5 and 1.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: This synchronous method may not be called from a callback of an async LogDevice API. This is checked, asserted in debug builds, and causes requests in release builds to fail. The reason is that we would already be on an internal LogDevice thread, the request would need to be processed by an internal LogDevice thread, and having one wait for another could result in deadlock. Use the async version below.</p>
<dl class="section return"><dt>Returns</dt><dd>If there's a range with name </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name,returns</td><td>a pair containing the lowest and highest log ids in the range (this may be the same id for log ranges of size 1). Otherwise returns a pair where both ids are set to LOGID_INVALID, and sets err to one of:<ul>
<li>E::OK Range found and set in the result</li>
<li>E::NOTFOUND Request succeeded, but a range with such name was not found</li>
<li>E::FAILED Request failed </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea15cbb86362e2c444bb52a3b130fce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea15cbb86362e2c444bb52a3b130fce3">&#9670;&nbsp;</a></span>getLogRangeByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::Client::getLogRangeByName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">get_log_range_by_name_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An async variant of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ac4d2aabc1842a955534ba9f215a44592">getLogRangeByName()</a>. This can be called from async LogDevice callbacks safely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>callback that will be called on an unspecified thread with the result. The callback can be called before or after the call to <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ac4d2aabc1842a955534ba9f215a44592">getLogRangeByName()</a> finishes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0817e65400f859da5f8c540d445d2a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0817e65400f859da5f8c540d445d2a4f">&#9670;&nbsp;</a></span>getLogRangesByNamespace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::map&lt;std::string, logid_range_t&gt; facebook::logdevice::Client::getLogRangesByNamespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Looks up the boundaries of all log ranges that have a "name" attribute set and belong to the namespace </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ns.</td><td>You can query nested namespaces by concatenating their names with namespace delimiters as returned by <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a5e29c336be53be4381ea32a7e2a677fa">getLogNamespaceDelimiter()</a> in between. E.g. if the namespace delimiter is '/', you can submit 'ns1/ns2/ns3' as the </td></tr>
    <tr><td class="paramname">ns</td><td>here.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: This synchronous method may not be called from a callback of an async LogDevice API. This is checked, asserted in debug builds, and causes requests in release builds to fail. The reason is that we would already be on an internal LogDevice thread, the request would need to be processed by an internal LogDevice thread, and having one wait for another could result in deadlock. Use the async version below.</p>
<dl class="section return"><dt>Returns</dt><dd>A map from log range name to a pair of the lowest and highest log ids in the range (this may be the same id for log ranges of size 1). If empty, err contains an error code if the operation failed, or E::OK if the operation succeeded but there are no log ranges in the namespace. </dd></dl>

</div>
</div>
<a id="a9e735441fafb4528afdbee9573cf371f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e735441fafb4528afdbee9573cf371f">&#9670;&nbsp;</a></span>getLogRangesByNamespace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::Client::getLogRangesByNamespace </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">get_log_ranges_by_namespace_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An async variant of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a0817e65400f859da5f8c540d445d2a4f">getLogRangesByNamespace()</a>. This can be called from async LogDevice callbacks safely.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>callback that will be called on an unspecified thread with the result. The callback can be called before or after the call to <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a0817e65400f859da5f8c540d445d2a4f">getLogRangesByNamespace()</a> finishes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a977eec4108a9f539d539b2cae820c247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977eec4108a9f539d539b2cae820c247">&#9670;&nbsp;</a></span>getMaxPayloadSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t facebook::logdevice::Client::getMaxPayloadSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>returns the maximum permitted payload size for this client. The default is 1MB, but this can be increased via changing the max-payload-size setting. </dd></dl>

</div>
</div>
<a id="a148372b0049445d9b63b06d5ac0d7613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a148372b0049445d9b63b06d5ac0d7613">&#9670;&nbsp;</a></span>getTailAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::getTailAttributes </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">get_tail_attributes_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A non-blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a5a487dfa98c0d77fe35980f5392abbf4">getTailAttributesSync()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>is the ID of the log for which to get the tail attributes </td></tr>
    <tr><td class="paramname">cb</td><td>will be called once the tail attributes of the log are determined or an error occurred. The possible status values are the same as for <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a5a487dfa98c0d77fe35980f5392abbf4">getTailAttributesSync()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfully scheduled, -1 otherwise. </dd></dl>

</div>
</div>
<a id="a5a487dfa98c0d77fe35980f5392abbf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a487dfa98c0d77fe35980f5392abbf4">&#9670;&nbsp;</a></span>getTailAttributesSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;LogTailAttributes&gt; facebook::logdevice::Client::getTailAttributesSync </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return current attributes of the tail of the log by sending request to sequencer.</p>
<p>NOTE: Can fail with E::AGAIN error in healthy cluster if sequencer can not determine result at this point.</p>
<p>For an empty log getTailAttributesSync(log_id)-&gt;valid() may return false</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>is the ID of the log for which to find the tail LSN; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to current attributes of the tail of the log if succeed or nullptr on error and err is set to: E::TIMEDOUT We could not get a reply from a sequencer in time; E::CONNFAILED Unable to reach a sequencer node; E::NOSEQUENCER Failed to determine which node runs the sequencer; E::FAILED Sequencer activation failed for some other reason e.g. due to E::SYSLIMIT, E::NOBUFS, E::TOOMANY(too many activations), E::NOTFOUND(log-id not found) or attributes values failed to be fetched for because of internal failure; E::NOBUFS if too many requests are pending to be delivered to Workers; E::SHUTDOWN Processor is shutting down; E::INTERNAL if attempt to write into the request pipe of a Worker failed. E::AGAIN Sequencer can not determine result at this point. E::ACCESS The service denied access to this client based on credentials presented</dd></dl>
<p>LogTailAttributes includes: last_released_real_lsn Sequence number of last written and released for delivery record of the log. last_timestamp Estimated timestamp of record with last_released_real_lsn sequence number. It may be slightly larger than real timestamp of a record with last_released_real_lsn lsn. byte_offset Amount of data in bytes written from the beginning of the log up to the end. </p>

</div>
</div>
<a id="ae5854411762db40e48ba2e74142297c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5854411762db40e48ba2e74142297c2">&#9670;&nbsp;</a></span>getTailLSN()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::getTailLSN </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">get_tail_lsn_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A non-blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a1f426c780bd844dcc55114bf3a9b4c5f">getTailLSNSync()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>is the ID of the log for which to get the tail LSN </td></tr>
    <tr><td class="paramname">cb</td><td>will be called once the tail LSN of the log is determined or an error occurred. The possible status values are the same as for <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a1f426c780bd844dcc55114bf3a9b4c5f">getTailLSNSync()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfuly scheduled, -1 otherwise. </dd></dl>

</div>
</div>
<a id="a1f426c780bd844dcc55114bf3a9b4c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f426c780bd844dcc55114bf3a9b4c5f">&#9670;&nbsp;</a></span>getTailLSNSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual lsn_t facebook::logdevice::Client::getTailLSNSync </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the sequence number that points to the tail of log <code>logid</code>. The returned LSN is guaranteed to be higher or equal than the LSN of any record that was successfully acknowledged as appended prior to this call.</p>
<p>Note that there can be benign gaps in the numbering sequence of a log. As such, it is not guaranteed that a record was assigned the returned sequencer number.</p>
<p>One can read the full content of a log by creating a reader to read from LSN_OLDEST until the LSN returned by this method. Note that it is not guaranteed that the full content of the log is immediately available for reading.</p>
<p>This method is blocking until the tail LSN could be determined, the timeout occurs, or an error occurred. The timeout is specified in the <code><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a22c6047d80ec6b513bef7d61883f0bb4">create()</a></code> method and can be overridden with <code><a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a2b30b82b19b71acd383c3f2fdbf321aa">setTimeout()</a></code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>is the ID of the log for which to find the tail LSN; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tail LSN issued by the sequencer of log <code>logid</code> or LSN_INVALID on error and err is set to: E::TIMEDOUT We could not get a reply from a sequencer in time; E::CONNFAILED Unable to reach a sequencer node; E::NOSEQUENCER Failed to determine which node runs the sequencer; E::FAILED Sequencer activation failed for some other reason e.g. due to E::SYSLIMIT, E::NOBUFS, E::TOOMANY(too many activations), E::NOTFOUND(log-id not found); E::NOBUFS if too many requests are pending to be delivered to Workers; E::SHUTDOWN Processor is shutting down; E::INTERNAL if attempt to write into the request pipe of a Worker failed. E::ACCESS The service denied access to this client based on credentials presented </dd></dl>

</div>
</div>
<a id="aa402ed205a3138575644c8b3e9e6df85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa402ed205a3138575644c8b3e9e6df85">&#9670;&nbsp;</a></span>isLogEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::isLogEmpty </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">is_empty_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A non-blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#acea7b4e3a8830fd9b7161470fce43f25">isLogEmptySync()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>is the ID of the log to check </td></tr>
    <tr><td class="paramname">cb</td><td>will be called once the state of the log is determined or an error occurred. The possible status values are the same as for <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#acea7b4e3a8830fd9b7161470fce43f25">isLogEmptySync()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfuly scheduled, -1 otherwise. </dd></dl>

</div>
</div>
<a id="acea7b4e3a8830fd9b7161470fce43f25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea7b4e3a8830fd9b7161470fce43f25">&#9670;&nbsp;</a></span>isLogEmptySync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::isLogEmptySync </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>empty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks wether a particular log is empty. This method is blocking until the state can be determined or an error occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>is the ID of the log to check </td></tr>
    <tr><td class="paramname">empty</td><td>will be set by this method to either true or false depending on the responses received by storage nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successful, -1 otherwise and sets logdevice::err to: INVALID_PARAM if the log ID is invalid, PARTIAL if we can't answer with certainty. The log is probably either empty or almost empty, and any records are probably not very recent. ACCESS if permission to access the log was denied FAILED if the state of the log could not be determined. NOBUFS if too many requests are pending to be delivered to Workers SHUTDOWN Processor is shutting down INTERNAL if attempt to write into the request pipe of a Worker failed TIMEDOUT None of the above happened before the client timeout ran out. </dd></dl>

</div>
</div>
<a id="a70bbf9403fb51a73c2124e55fb97d0f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bbf9403fb51a73c2124e55fb97d0f4">&#9670;&nbsp;</a></span>makeDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::makeDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mk_intermediate_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const client::LogAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">make_directory_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new directory in LogsConfig.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the directory you want to create. </td></tr>
    <tr><td class="paramname">mk_intermediate_dirs</td><td>creates the directories in the supplied path if they don't exist. </td></tr>
    <tr><td class="paramname">attrs</td><td>The attributes of the target directory.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfuly scheduled, -1 otherwise. sets err to one of: E::ACCESS you don't have permissions to mutate the logs configuration. E::EXISTS Directory already exists. E::NOTFOUND the parent directory does not exit E::TIMEDOUT Operation timed out. </dd></dl>

</div>
</div>
<a id="a553df78853ca09da72c8c090ab1904f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553df78853ca09da72c8c090ab1904f9">&#9670;&nbsp;</a></span>makeDirectorySync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;client::Directory&gt; facebook::logdevice::Client::makeDirectorySync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mk_intermediate_dirs</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const client::LogAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em> = <code>client::LogAttributes()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>failure_reason</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a70bbf9403fb51a73c2124e55fb97d0f4">makeDirectory()</a> If failure_reason is not nullptr, it will be populated with a human-readable error string if the operation failed. </p><dl class="section return"><dt>Returns</dt><dd>the newly created Directory or nullptr. In case of nullptr the err will be set like the async counterpart. </dd></dl>

</div>
</div>
<a id="af5d99be796b2bdba8e9da20b08b04719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d99be796b2bdba8e9da20b08b04719">&#9670;&nbsp;</a></span>makeLogGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::makeLogGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const logid_range_t &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const client::LogAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mk_intermediate_dirs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">make_log_group_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a log group under a specific directory path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mk_intermediate_dirs</td><td>creates the directories in the supplied path if they don't exist. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfuly scheduled, -1 otherwise. sets err to one of: E::ID_CLASH the ID range clashes with existing log group. E::INVALID_ATTRIBUTES After applying the parent attributes and the supplied attributes, the resulting attributes are not valid. E::NOTFOUND source path doesn't exist. E::NOTDIR if the parent of destination path doesn't exist and mk_intermediate_dirs is false. E::EXISTS the destination path already exists! E::TIMEDOUT Operation timed out. E::ACCESS you don't have permissions to mutate the logs configuration. </dd></dl>

</div>
</div>
<a id="a54632fc9babcbe30d475e2da23f914f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54632fc9babcbe30d475e2da23f914f6">&#9670;&nbsp;</a></span>makeLogGroupSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;client::LogGroup&gt; facebook::logdevice::Client::makeLogGroupSync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const logid_range_t &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const client::LogAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em> = <code>client::LogAttributes()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mk_intermediate_dirs</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>failure_reason</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#af5d99be796b2bdba8e9da20b08b04719">makeLogGroup()</a> If failure_reason is not nullptr, it will be populated with a human-readable error string if the operation failed. </p>

</div>
</div>
<a id="a9828b92a8b696b1649b515f1fb157547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9828b92a8b696b1649b515f1fb157547">&#9670;&nbsp;</a></span>notifyOnLogsConfigVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classfacebook_1_1logdevice_1_1_config_subscription_handle.html">ConfigSubscriptionHandle</a> facebook::logdevice::Client::notifyOnLogsConfigVersion </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The callback will be called when the LogsConfig on this client has at least the version passed to this function (first argument).</p>
<dl class="section return"><dt>Returns</dt><dd>The returned subscription handle that the client needs to hold for as long as the client is still interested in this. If the client deleted that handle, the subscription will be destroyed and the callback will not be called. </dd></dl>

</div>
</div>
<a id="ab8e0bcb6f9dabd95d40b1b63a98448ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e0bcb6f9dabd95d40b1b63a98448ab">&#9670;&nbsp;</a></span>publishEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::Client::publishEvent </td>
          <td>(</td>
          <td class="paramtype">Severity&#160;</td>
          <td class="paramname"><em>sev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name_space</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>data</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>context</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Emit a user defined event to the event logging system.</p>
<p>User events are intended to be used to for debugging and to make failures or performance issues visible. User events are aggregated with client library events so that customer visible issues can be easily correlated with internal failures.</p>
<p>NOTE: User events are rate limited to 10 events in every 10s.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sev</td><td>Event Severity. Can be one of: CRITICAL, ERROR, WARNING, NOTICE, INFO, or DEBUG.</td></tr>
    <tr><td class="paramname">name_space</td><td>The name_space argument ensures overlapping types allocated by different customers are not ambiguous. Namespace identifiers that start with "LD_" are reserved for internal use by the LogDevice library.</td></tr>
    <tr><td class="paramname">type</td><td>String representation of an event type enumeration.</td></tr>
    <tr><td class="paramname">data</td><td>Supporting information for the event type. Optional.</td></tr>
    <tr><td class="paramname">context</td><td>Program context (e.g. stack trace) that may aid in understanding the cause of the event. Optional. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1697b6688a972f991a05c706bdcecdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1697b6688a972f991a05c706bdcecdf">&#9670;&nbsp;</a></span>removeDirectory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::removeDirectory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">status_callback_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove a directory if it's empty:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the directory you want to remove. </td></tr>
    <tr><td class="paramname">recursive</td><td>Removes the directory recursively, If the supplied path is the root directory, the full tree will be removed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfuly scheduled, -1 otherwise. sets err to one of: E::ACCESS you don't have permissions to mutate the logs configuration. E::EXISTS Directory already exists. E::TIMEDOUT Operation timed out. E::NOTFOUND the directory was not found and thus couldn't be deleted. </dd></dl>

</div>
</div>
<a id="a56747c28caeca0476ad42495cd2d00ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56747c28caeca0476ad42495cd2d00ca">&#9670;&nbsp;</a></span>removeDirectorySync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool facebook::logdevice::Client::removeDirectorySync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>recursive</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aa1697b6688a972f991a05c706bdcecdf">removeDirectory()</a> </p><dl class="section return"><dt>Returns</dt><dd>true if removed, otherwise the err will be set like its async counterpart. </dd></dl>

</div>
</div>
<a id="a0f09c107d0083cf3e23538dca8b430bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f09c107d0083cf3e23538dca8b430bb">&#9670;&nbsp;</a></span>removeLogGroup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::removeLogGroup </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">status_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a logGroup defined at path</p>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfuly scheduled, -1 otherwise. sets err to one of: E::NOTFOUND it was not found E::TIMEDOUT Operation timed out. E::ACCESS you don't have permissions to mutate the logs configuration. </dd></dl>

</div>
</div>
<a id="a1a2c5b528fdeca565cb837d2e307df34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2c5b528fdeca565cb837d2e307df34">&#9670;&nbsp;</a></span>removeLogGroupSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool facebook::logdevice::Client::removeLogGroupSync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a0f09c107d0083cf3e23538dca8b430bb">removeLogGroup()</a></p>
<dl class="section return"><dt>Returns</dt><dd>true if removed, otherwise err will be set as the async counterpart. </dd></dl>

</div>
</div>
<a id="a9c3bcf709656e91fc65a82ee32e6634c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3bcf709656e91fc65a82ee32e6634c">&#9670;&nbsp;</a></span>rename()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::rename </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">status_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rename the leaf of the supplied path. This does not move entities in the tree it only renames the last token in the path supplies.</p>
<p>The new path is the full path of the destination, it must not exist, otherwise you will receive status of E::EXISTS </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_path</td><td>The source path to rename </td></tr>
    <tr><td class="paramname">to_path</td><td>The new path you are renaming to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfuly scheduled, -1 otherwise. sets err to one of: E::INVALID_PARAM if paths are invalid, a common example is that source or destination are the root path. or that the source and destination are the same. E::NOTFOUND source path doesn't exist. E::EXISTS the destination path already exists! E::TIMEDOUT Operation timed out. E::ACCESS you don't have permissions to mutate the logs configuration. </dd></dl>

</div>
</div>
<a id="adea81d5b164611e4da5a6878458b51e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea81d5b164611e4da5a6878458b51e0">&#9670;&nbsp;</a></span>renameSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool facebook::logdevice::Client::renameSync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>from_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>to_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>failure_reason</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a9c3bcf709656e91fc65a82ee32e6634c">rename()</a> If failure_reason is not nullptr, it will be populated with a human-readable error string if the operation failed. Return true if rename was successful, otherwise err is set like the async counterpart. </p>

</div>
</div>
<a id="a771e6e5420f578bac83c51da04c878c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771e6e5420f578bac83c51da04c878c2">&#9670;&nbsp;</a></span>setAttributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::setAttributes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const client::LogAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">status_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This sets either a LogGroup or LogsDirectory attributes to the supplied attributes object. If the path refers to directory, all child directories and log groups will be updated accordingly.</p>
<dl class="section return"><dt>Returns</dt><dd>0 if the request was successfuly scheduled, -1 otherwise. sets err to one of: E::INVALID_ATTRIBUTES After applying the parent attributes and the supplied attributes, the resulting attributes are not valid. E::NOTFOUND the path supplied doesn't exist. E::TIMEDOUT Operation timed out. E::ACCESS you don't have permissions to mutate the logs configuration. </dd></dl>

</div>
</div>
<a id="a1692d455a2c608dbcecd675123338c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1692d455a2c608dbcecd675123338c7a">&#9670;&nbsp;</a></span>setAttributesSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool facebook::logdevice::Client::setAttributesSync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const client::LogAttributes &amp;&#160;</td>
          <td class="paramname"><em>attrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>failure_reason</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a771e6e5420f578bac83c51da04c878c2">setAttributes()</a> If failure_reason is not nullptr, it will be populated with a human-readable error string if the operation failed. </p>

</div>
</div>
<a id="aaef92340ce40a5f12b0e9b685595145a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaef92340ce40a5f12b0e9b685595145a">&#9670;&nbsp;</a></span>setLogGroupRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::setLogGroupRange </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const logid_range_t &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">status_callback_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This sets the log group range to the supplied new range. </p><dl class="section return"><dt>Returns</dt><dd>0 on success, -1 otherwise and sets <code>err</code> to: E::ID_CLASH the ID range clashes with existing log group. E::NOTFOUND if the path doesn't exist or it's pointing to a directory E::INVALID_ATTRIBUTES the range you supplied is invalid or reserved for system-logs. E::TIMEDOUT Operation timed out. E::ACCESS you don't have permissions to mutate the logs configuration. </dd></dl>

</div>
</div>
<a id="ab7c94850b340bcc37cda74f35f9183d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c94850b340bcc37cda74f35f9183d0">&#9670;&nbsp;</a></span>setLogGroupRangeSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool facebook::logdevice::Client::setLogGroupRangeSync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const logid_range_t &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>failure_reason</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#aaef92340ce40a5f12b0e9b685595145a">setLogGroupRange()</a> If failure_reason is not nullptr, it will be populated with a human-readable error string if the operation failed. </p>

</div>
</div>
<a id="a2b30b82b19b71acd383c3f2fdbf321aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b30b82b19b71acd383c3f2fdbf321aa">&#9670;&nbsp;</a></span>setTimeout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::Client::setTimeout </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Overrides the timeout value passed to <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a22c6047d80ec6b513bef7d61883f0bb4">Client::create()</a> everywhere that timeout is used. </p>

</div>
</div>
<a id="aafa91f8e42039d4f7606d1c7668f37ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa91f8e42039d4f7606d1c7668f37ea">&#9670;&nbsp;</a></span>settings()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classfacebook_1_1logdevice_1_1_client_settings.html">ClientSettings</a>&amp; facebook::logdevice::Client::settings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exposes a <a class="el" href="classfacebook_1_1logdevice_1_1_client_settings.html">ClientSettings</a> instance that can be used to change settings for the <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a>. </p>

</div>
</div>
<a id="a5189e872667a158b8837da87185ab7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5189e872667a158b8837da87185ab7ec">&#9670;&nbsp;</a></span>subscribeToConfigUpdates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classfacebook_1_1logdevice_1_1_config_subscription_handle.html">ConfigSubscriptionHandle</a> facebook::logdevice::Client::subscribeToConfigUpdates </td>
          <td>(</td>
          <td class="paramtype">config_update_callback_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes to notifications of configuration file updates.</p>
<p>Whenever the LogDevice client library picks up a new config, it will call the supplied callback on an unspecified thread after the new config is loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>the callback to call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the subscription handle. The subscription will be valid as long as the handle exists. Subscription will cease and the callback will not be called after the handle is destroyed. </dd></dl>

</div>
</div>
<a id="a34c95d7cb5a1ad1951f4fb2ad292a325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c95d7cb5a1ad1951f4fb2ad292a325">&#9670;&nbsp;</a></span>syncLogsConfigVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool facebook::logdevice::Client::syncLogsConfigVersion </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This waits (blocks) until the LogsConfig satisfy the supplied predicate or until the timeout has passed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>The minimum version you need to sync LogsConfig to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful false on timeout. This will set the <code>err</code> to E::TIMEDOUT. </dd></dl>

</div>
</div>
<a id="a51dbf28a3fc8266e4662a71deb73c21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51dbf28a3fc8266e4662a71deb73c21a">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::trim </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">trim_callback_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A non-blocking version of <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a01eb0f0c77e1c55ad2958a05aad4bdc3">trimSync()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>If the request was successfully submitted for processing, returns 0. In that case, the supplied callback is guaranteed to be called at a later time with the outcome of the request. See <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a01eb0f0c77e1c55ad2958a05aad4bdc3">trimSync()</a> for documentation for the result. Otherwise, returns -1. </dd></dl>

</div>
</div>
<a id="a01eb0f0c77e1c55ad2958a05aad4bdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01eb0f0c77e1c55ad2958a05aad4bdc3">&#9670;&nbsp;</a></span>trimSync()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::Client::trimSync </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>logid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>lsn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ask LogDevice cluster to trim the log up to and including the specified LSN. After the operation successfully completes records with LSNs up to 'lsn' are no longer accessible to LogDevice clients.</p>
<p>This method is synchronous &ndash; it blocks until all storage nodes acknowledge the trim command, the timeout occurs, or the provided credentials are invalid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">logid</td><td>ID of log to trim </td></tr>
    <tr><td class="paramname">lsn</td><td>Trim the log up to this LSN (inclusive), should not be larger than the LSN of the most recent record available to readers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 if the request was successfully acknowledged by all nodes. Otherwise, returns -1 with logdevice::err set to</dd></dl>
<p>E::INVALID_PARAM logid or lsn is invalid E::FAILED FAILED to trim on all storage nodes E::PARTIAL if some, but not all, nodes successfully trimmed the log. In this case, some storage nodes might not have trimmed their part of the log, so records with LSNs less than or equal to 'lsn' might still be delivered). E::ACCESS <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> has invalid credentials or client does not have the correct permissions to perform the trim operation. E::NOTFOUND There is no log with such logid. E::TOOBIG The trim LSN is beyond the tail of the log. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>logdevice/include/<a class="el" href="_client_8h_source.html">Client.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer">
<small>
LogDevice API
</small>
</address>
</body>
</html>
