<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>LogDevice API: facebook::logdevice::AsyncReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">LogDevice API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefacebook.html">facebook</a></li><li class="navelem"><b>logdevice</b></li><li class="navelem"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classfacebook_1_1logdevice_1_1_async_reader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">facebook::logdevice::AsyncReader Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5178eed40dc11734b248565c2009a06f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a5178eed40dc11734b248565c2009a06f">setRecordCallback</a> (std::function&lt; bool(std::unique_ptr&lt; DataRecord &gt; &amp;)&gt;)=0</td></tr>
<tr class="separator:a5178eed40dc11734b248565c2009a06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161d3d09e946c826c7797c25e4bc27a2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a161d3d09e946c826c7797c25e4bc27a2">setGapCallback</a> (std::function&lt; bool(const GapRecord &amp;)&gt;)=0</td></tr>
<tr class="separator:a161d3d09e946c826c7797c25e4bc27a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437d725a72d1283d9be47cbb2e480183"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a437d725a72d1283d9be47cbb2e480183">setDoneCallback</a> (std::function&lt; void(logid_t)&gt;)=0</td></tr>
<tr class="separator:a437d725a72d1283d9be47cbb2e480183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac22c5e34091c1bfe6ceea1c24fde335"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#aac22c5e34091c1bfe6ceea1c24fde335">setHealthChangeCallback</a> (std::function&lt; void(logid_t, HealthChangeType)&gt;)=0</td></tr>
<tr class="separator:aac22c5e34091c1bfe6ceea1c24fde335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13331e00d2b9fd60c3d956927dd3cefc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a13331e00d2b9fd60c3d956927dd3cefc">startReading</a> (logid_t log_id, lsn_t from, lsn_t until=LSN_MAX, const ReadStreamAttributes *attrs=nullptr)=0</td></tr>
<tr class="separator:a13331e00d2b9fd60c3d956927dd3cefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e26fd1ce23777a8af17922a3005f1ef"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a7e26fd1ce23777a8af17922a3005f1ef">stopReading</a> (logid_t log_id, std::function&lt; void()&gt; callback=nullptr)=0</td></tr>
<tr class="separator:a7e26fd1ce23777a8af17922a3005f1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6742bbd7a2a61566d8a1deb44ff25f"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#aed6742bbd7a2a61566d8a1deb44ff25f">resumeReading</a> (logid_t log_id)=0</td></tr>
<tr class="separator:aed6742bbd7a2a61566d8a1deb44ff25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b684294bf9b6c97ab26671a5bb3894"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a59b684294bf9b6c97ab26671a5bb3894">withoutPayload</a> ()=0</td></tr>
<tr class="separator:a59b684294bf9b6c97ab26671a5bb3894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12350808c55ead68ad150cd8c6bec59"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#ae12350808c55ead68ad150cd8c6bec59">forceNoSingleCopyDelivery</a> ()=0</td></tr>
<tr class="separator:ae12350808c55ead68ad150cd8c6bec59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d29d960a147d0ccfef20edabf523a16"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a1d29d960a147d0ccfef20edabf523a16">includeByteOffset</a> ()=0</td></tr>
<tr class="separator:a1d29d960a147d0ccfef20edabf523a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42800430d4e5c088b81c1c271857a95"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#ad42800430d4e5c088b81c1c271857a95">doNotSkipPartiallyTrimmedSections</a> ()=0</td></tr>
<tr class="separator:ad42800430d4e5c088b81c1c271857a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272afa75bca495b89dfd2cc5e400a4d1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a272afa75bca495b89dfd2cc5e400a4d1">isConnectionHealthy</a> (logid_t) const =0</td></tr>
<tr class="separator:a272afa75bca495b89dfd2cc5e400a4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccc11109a00b0806cc213567f37929c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a8ccc11109a00b0806cc213567f37929c">doNotDecodeBufferedWrites</a> ()=0</td></tr>
<tr class="separator:a8ccc11109a00b0806cc213567f37929c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515c9bd5aafeb7885ae4514dac88191d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a515c9bd5aafeb7885ae4514dac88191d">getBytesBuffered</a> (std::function&lt; void(size_t)&gt; callback)=0</td></tr>
<tr class="separator:a515c9bd5aafeb7885ae4514dac88191d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5059c10f5e16a5c6dfb78c6b0a5d6733"><td class="memItemLeft" align="right" valign="top">static lsn_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a5059c10f5e16a5c6dfb78c6b0a5d6733">nextFromLsnWhenStuck</a> (lsn_t stuck_lsn=LSN_INVALID, lsn_t tail_lsn=LSN_INVALID)</td></tr>
<tr class="separator:a5059c10f5e16a5c6dfb78c6b0a5d6733"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8ccc11109a00b0806cc213567f37929c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccc11109a00b0806cc213567f37929c">&#9670;&nbsp;</a></span>doNotDecodeBufferedWrites()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::AsyncReader::doNotDecodeBufferedWrites </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Instructs the <a class="el" href="classfacebook_1_1logdevice_1_1_reader.html">Reader</a> instance to pass through blobs created by BufferedWriter.</p>
<p>By default (if this method is not called), <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a> automatically decodes blobs written by BufferedWriter and yields original records as passed to BufferedWriter::append(). If this method is called, BufferedWriteDecoder can be used to decode the blobs. </p>

</div>
</div>
<a id="ad42800430d4e5c088b81c1c271857a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42800430d4e5c088b81c1c271857a95">&#9670;&nbsp;</a></span>doNotSkipPartiallyTrimmedSections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::AsyncReader::doNotSkipPartiallyTrimmedSections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If called, when reading a section of the log that has been partially trimmed, the reader will deliver whatever records are still available, which (because of LogDevice's distributed and nondeterministic nature) results in an interleaved stream of records and TRIM gaps, which is undesirable in some cases.</p>
<p>The default behaviour is to deliver a large trim gap for the entire section.</p>
<p>See doc/partially-trimmed.md for a detailed explanation. </p>

</div>
</div>
<a id="ae12350808c55ead68ad150cd8c6bec59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12350808c55ead68ad150cd8c6bec59">&#9670;&nbsp;</a></span>forceNoSingleCopyDelivery()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::AsyncReader::forceNoSingleCopyDelivery </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If called, disable the single copy delivery optimization even if the log is configured to support it. Each data record will be sent by all storage nodes that have a copy instead of exactly one. This greatly increases read availability at the cost of higher network bandwith and cpu usage.</p>
<p>Only affects subsequent <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a13331e00d2b9fd60c3d956927dd3cefc">startReading()</a> calls. </p>

</div>
</div>
<a id="a515c9bd5aafeb7885ae4514dac88191d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515c9bd5aafeb7885ae4514dac88191d">&#9670;&nbsp;</a></span>getBytesBuffered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::AsyncReader::getBytesBuffered </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(size_t)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Report the size (in bytes) of the data records that the underlying ClientReadStreamBuffers currently occupy </p>

</div>
</div>
<a id="a1d29d960a147d0ccfef20edabf523a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d29d960a147d0ccfef20edabf523a16">&#9670;&nbsp;</a></span>includeByteOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::AsyncReader::includeByteOffset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If called, data records read by this <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a> will start including approximate amount of data written to given log up to current record once it become available to <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a>.</p>
<p>The value itself stored in DataRecord::attrs::byte_offset. Set as BYTE_OFFSET_INVALID if unavailable to <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a> yet.</p>
<p>Only affects subsequent <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a13331e00d2b9fd60c3d956927dd3cefc">startReading()</a> calls. </p>

</div>
</div>
<a id="a272afa75bca495b89dfd2cc5e400a4d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272afa75bca495b89dfd2cc5e400a4d1">&#9670;&nbsp;</a></span>isConnectionHealthy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::AsyncReader::isConnectionHealthy </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if the connection to the LogDevice cluster for a log appears healthy. When a read() call times out, this can be used to make an informed guess whether this is because there is no data or because there a service interruption.</p>
<p>NOTE: this is not 100% accurate but will expose common issues like losing network connectivity.</p>
<dl class="section return"><dt>Returns</dt><dd>On success, returns 1 if the connection appears healthy or 0 if there are issues talking to the cluster. On error returns -1 and sets err to NOTFOUND (not reading given log). </dd></dl>

</div>
</div>
<a id="a5059c10f5e16a5c6dfb78c6b0a5d6733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5059c10f5e16a5c6dfb78c6b0a5d6733">&#9670;&nbsp;</a></span>nextFromLsnWhenStuck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static lsn_t facebook::logdevice::AsyncReader::nextFromLsnWhenStuck </td>
          <td>(</td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>stuck_lsn</em> = <code>LSN_INVALID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>tail_lsn</em> = <code>LSN_INVALID</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get next lowest recommended LSN to read from when servers appear stuck.</p>
<p>To force progress when stuck at <code>stuck_lsn</code>, call <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a7e26fd1ce23777a8af17922a3005f1ef">stopReading()</a>, then call <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a13331e00d2b9fd60c3d956927dd3cefc">startReading()</a> from nextFromLsnWhenStuck(stuck_lsn).</p>
<p>NOTE: Forcing progress is likely to miss some records between stuck_lsn and nextFromLsnWhenStuck(stuck_lsn). The records will become available eventually (once server-side issues have been resolved), but the only way to read them is to re-read the section from stuck_lsn to nextFromLsnWhenStuck(stuck_lsn) later.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stuck_lsn</td><td>LSN at which the reader got stuck; that is, the last LSN the reader tried to read or managed to read (+-1 does not affect the output of this function). </td></tr>
    <tr><td class="paramname">tail_lsn</td><td>Tail LSN, if known, as returned by <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#ae5854411762db40e48ba2e74142297c2">Client::getTailLSN()</a> or <a class="el" href="classfacebook_1_1logdevice_1_1_client.html#a1e0c38ddae87c659ff68bbea760f020b">Client::findTime()</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Recommended LSN to use as <code>from_lsn</code> in startRead() to make progress, no less than <code>stuck_lsn</code>. </dd></dl>

</div>
</div>
<a id="aed6742bbd7a2a61566d8a1deb44ff25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6742bbd7a2a61566d8a1deb44ff25f">&#9670;&nbsp;</a></span>resumeReading()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::AsyncReader::resumeReading </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>log_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Requests delivery for a log to resume after a previous delivery was declined (callback returned false). This can be used to avoid waiting on the redelivery timer when the callback becomes ready to accept new records.</p>
<p>NOTE: involves interthread communication which can fail if the queues fill up. However, no failure handling is generally needed because delivery is retried on a timer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_id</td><td>log ID to stop reading</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned if resume request was successfully enqueued for delivery. On failure -1 is returned and logdevice::err is set to NOBUFS if request could not be enqueued because a buffer space limit was reached NOTFOUND if reading was not started for specified log </dd></dl>

</div>
</div>
<a id="a437d725a72d1283d9be47cbb2e480183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437d725a72d1283d9be47cbb2e480183">&#9670;&nbsp;</a></span>setDoneCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::AsyncReader::setDoneCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(logid_t)&gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a callback that the LogDevice client library will call when it has finished reading the requested range of LSNs. </p>

</div>
</div>
<a id="a161d3d09e946c826c7797c25e4bc27a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161d3d09e946c826c7797c25e4bc27a2">&#9670;&nbsp;</a></span>setGapCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::AsyncReader::setGapCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(const GapRecord &amp;)&gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a callback that the LogDevice client library will call when a gap record is delivered for this log. A gap record informs the reader about gaps in the sequence of record numbers. In most cases such gaps are benign and not an indication of data loss. See class GapRecord in Record.h for details.</p>
<p>The callback should return true if the gap was successfully consumed. If the callback returns false, delivery of the same gap will be retried after some time. Redelivery can also be requested with a <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#aed6742bbd7a2a61566d8a1deb44ff25f">resumeReading()</a> call. </p>

</div>
</div>
<a id="aac22c5e34091c1bfe6ceea1c24fde335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac22c5e34091c1bfe6ceea1c24fde335">&#9670;&nbsp;</a></span>setHealthChangeCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::AsyncReader::setHealthChangeCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(logid_t, HealthChangeType)&gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a callback that the LogDevice client library will call when a health change is detected for any log it is reading from.</p>
<p>The callback receives as parameters the log ID for which the change was detected and a status reporting the type of health change. </p>

</div>
</div>
<a id="a5178eed40dc11734b248565c2009a06f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5178eed40dc11734b248565c2009a06f">&#9670;&nbsp;</a></span>setRecordCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::AsyncReader::setRecordCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(std::unique_ptr&lt; DataRecord &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a callback that the LogDevice client library will call when a record is read.</p>
<p>The callback should return true if the record was successfully consumed. If the callback returns false, delivery of the same record will be retried after some time. Redelivery can also be requested with a <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#aed6742bbd7a2a61566d8a1deb44ff25f">resumeReading()</a> call.</p>
<p>NOTE: The callback must not drain the input unique_ptr&amp; if it return false (this is asserted in debug builds).</p>
<p>Only affects subsequent <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a13331e00d2b9fd60c3d956927dd3cefc">startReading()</a> calls; calling <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a13331e00d2b9fd60c3d956927dd3cefc">startReading()</a> first and <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a5178eed40dc11734b248565c2009a06f">setRecordCallback()</a> after has no effect. </p>

</div>
</div>
<a id="a13331e00d2b9fd60c3d956927dd3cefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13331e00d2b9fd60c3d956927dd3cefc">&#9670;&nbsp;</a></span>startReading()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::AsyncReader::startReading </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>log_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">lsn_t&#160;</td>
          <td class="paramname"><em>until</em> = <code>LSN_MAX</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ReadStreamAttributes *&#160;</td>
          <td class="paramname"><em>attrs</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start reading records from a log in a specified range of LSNs. The function will return as soon as the request is put on a local queue. Upon successful return, the next record to be delivered to a callback will be as described in </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>below.</td></tr>
  </table>
  </dd>
</dl>
<p>If the log is already being read by this <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a>, this method stops reading and starts again with the new parameters. However, the stopping is asynchronous. For a short time you may see records from both the old and the new stream, interleaved arbitrarily. If you need a clean cutover, call <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a7e26fd1ce23777a8af17922a3005f1ef">stopReading()</a> (passing a callback), then <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a13331e00d2b9fd60c3d956927dd3cefc">startReading()</a> after the callback is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_id</td><td>log ID to start reading</td></tr>
    <tr><td class="paramname">from</td><td>log sequence number (LSN) to move the read pointer to. If this LSN identifies a data record currently in the log, that record will be the next one delivered to a data callback installed for the log, or to a <a class="el" href="classfacebook_1_1logdevice_1_1_reader.html">Reader</a> object for the log.</td></tr>
  </table>
  </dd>
</dl>
<p>If the lowest (oldest) LSN in the log is greater than this value, the read pointer will move to the oldest record in the log and that record will be the next one delivered. See LSN_OLDEST in types.h.</p>
<p>If <em>from</em> falls into a gap in the numbering sequence, the next record delivered to this reader will be the gap record.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">until</td><td>the highest LSN the LogDevice cluster will deliver to this <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a> object. Once this LSN is reached, the LogDevice client library will call the done callback. The client must call <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a13331e00d2b9fd60c3d956927dd3cefc">startReading()</a> again in order to continue delivery. If the read pointer comes across a sequence gap that includes this LSN, the delivery stops after the gap record is delivered. By default (see LSN_MAX in types.h) records continue to be delivered in sequence until delivery is explicitly cancelled by a call to <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a7e26fd1ce23777a8af17922a3005f1ef">stopReading()</a> below, or altered by another call to <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a13331e00d2b9fd60c3d956927dd3cefc">startReading()</a>.</td></tr>
    <tr><td class="paramname">attrs</td><td>Structure containing parameters that alter the behavior of the read stream. In particular it is used to pass filters for the server-side filtering experimental feature.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned if the request was successfully enqueued for delivery. On failure -1 is returned and logdevice::err is set to NOBUFS if request could not be enqueued because a buffer space limit was reached INVALID_PARAM if from &gt; until or the record callback was not specified. SHUTDOWN the <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">logdevice::Client</a> instance was destroyed. INTERNAL An internal error has been detected, check logs. </dd></dl>

</div>
</div>
<a id="a7e26fd1ce23777a8af17922a3005f1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e26fd1ce23777a8af17922a3005f1ef">&#9670;&nbsp;</a></span>stopReading()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int facebook::logdevice::AsyncReader::stopReading </td>
          <td>(</td>
          <td class="paramtype">logid_t&#160;</td>
          <td class="paramname"><em>log_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>callback</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ask LogDevice cluster to stop delivery of this log's records. The callbacks registered for the log or the <a class="el" href="classfacebook_1_1logdevice_1_1_reader.html">Reader</a> object reading records from this log will stop receiving this log's records until one of <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a13331e00d2b9fd60c3d956927dd3cefc">startReading()</a> methods is called again.</p>
<p>The function returns as soon as the request is put on a local queue. However, record/gap callbacks may continue to be called for the log until a <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> thread is able to process the stop request. After the optional callback is called (on the <a class="el" href="classfacebook_1_1logdevice_1_1_client.html">Client</a> thread), it is guaranted that no further records or gaps will be delivered. The callback is called exactly once, but might be called during or after <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a> destruction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">log_id</td><td>log ID to stop reading </td></tr>
    <tr><td class="paramname">callback</td><td>optional callback to invoke when the request has taken effect and no more records will be delivered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 is returned if a stop request was successfully enqueued for delivery. On failure -1 is returned and logdevice::err is set to NOTFOUND if reading was not started for specified log </dd></dl>

</div>
</div>
<a id="a59b684294bf9b6c97ab26671a5bb3894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b684294bf9b6c97ab26671a5bb3894">&#9670;&nbsp;</a></span>withoutPayload()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void facebook::logdevice::AsyncReader::withoutPayload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If called, data records read by this <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html">AsyncReader</a> will not include payloads.</p>
<p>This makes reading more efficient when payloads are not needed (they won't be transmitted over the network).</p>
<p>Only affects subsequent <a class="el" href="classfacebook_1_1logdevice_1_1_async_reader.html#a13331e00d2b9fd60c3d956927dd3cefc">startReading()</a> calls. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>logdevice/include/<a class="el" href="_async_reader_8h_source.html">AsyncReader.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer">
<small>
LogDevice API
</small>
</address>
</body>
</html>
